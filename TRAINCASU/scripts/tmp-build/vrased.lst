
vrased.elf:     file format elf32-msp430

SYMBOL TABLE:
0000e000 l    d  .text	00000000 .text
0000a000 l    d  .srom1	00000000 .srom1
0000dc00 l    d  .isr1	00000000 .isr1
0000de00 l    d  .isr2	00000000 .isr2
0000dffe l    d  .srom2	00000000 .srom2
00000200 l    d  .data	00000000 .data
00000228 l    d  .sstack	00000000 .sstack
00001228 l    d  .bss	00000000 .bss
00001340 l    d  .noinit	00000000 .noinit
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 main.c
0000e092 l       .text	00000000 __br_unexpected_
00000000 l    df *ABS*	00000000 wrapper.c
00000000 l    df *ABS*	00000000 Hacl_HMAC_SHA2_256.c
0000a6a0 l     F .srom1	00000362 Hacl_Impl_SHA2_256_init
0000aa02 l     F .srom1	00000028 Hacl_Impl_HMAC_SHA2_256_xor_bytes_inplace
0000aa2a l     F .srom1	00000634 Hacl_Impl_SHA2_256_update
0000b05e l     F .srom1	00000046 Hacl_Impl_SHA2_256_update_multi
0000b0a4 l     F .srom1	00000262 Hacl_Impl_SHA2_256_update_last
0000b306 l     F .srom1	000000e6 Hacl_Impl_SHA2_256_finish
0000b3ec l     F .srom1	000000a0 Hacl_Impl_SHA2_256_hash
0000b48c l     F .srom1	0000015c Hacl_Impl_HMAC_SHA2_256_hmac_core
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00001228 g     O .bss	00000001 rx_end
00010000 g       *ABS*	00000000 _far_end
00000028 g       *ABS*	00000000 __data_size
0000e092  w      .text	00000000 __isr_14
0000e0b4 g     F .text	0000000a initLed
0000a12e g     F .srom1	00000048 secure_memcmp
0000e092  w      .text	00000000 __isr_4
00000138 g       *ABS*	00000000 __OP2
0000a204 g     F .srom1	0000008e recv_buf
0000dc00 g     F .isr1	000001c0 timer
0000a650 g     F .srom1	00000050 time_sync
00010000 g       *ABS*	00000000 _efartext
00000130 g       *ABS*	00000000 __MPY
0000013a g       *ABS*	00000000 __RESLO
00000136 g       *ABS*	00000000 __MACS
0000e000 g       *ABS*	00000000 _etext
00000118 g       *ABS*	00000000 __bss_size
0000e000  w      .text	00000000 __watchdog_support
0000e08c  w      .text	00000000 __stop_progExec__
0000b658 g     F .srom1	000000fa memcpy
0000a07c g     F .srom1	000000b2 CASU_update_install
0000de00 g       .isr2	00000000 __isr_11
0000122c g     O .bss	00000004 parent
0000b5e8 g     F .srom1	00000006 hash
0000122a g     O .bss	00000001 rx_start
0000e092  w      .text	00000000 __isr_5
0000e128 g       *ABS*	00000000 __data_load_start
0000e092 g       .text	00000000 __dtors_end
00001340 g       .bss	00000000 __bss_end
0000e092  w      .text	00000000 __isr_2
0000e0be g     F .text	00000068 CASU_secure_update
0000e092  w      .text	00000000 __isr_10
0000013c g       *ABS*	00000000 __RESHI
00001340 g     O .noinit	00000002 __wdt_clear_value
0000e092  w      .text	00000000 __isr_7
0000ffe0 g     O .vectors	00000020 __ivtbl_16
0000123c g     O .bss	00000100 rxdata
0000e092  w      .text	00000000 __isr_0
00000204 g     O .data	00000004 cur_hash_idx
0000e028  w      .text	00000000 __do_clear_bss
0000a000 g     F .srom1	00000024 tcb_entry
0000dffe g     F .srom2	00000002 CASU_exit
0000133c g     O .bss	00000004 epoch_time
0000e126  w      .text	00000000 _unexpected_
0000e092  w      .text	00000000 __isr_8
0000a024 g     F .srom1	0000002a CASU_jump_to_ER_routine_init
0000e092  w      .text	00000000 __isr_3
0000ffe0 g       .vectors	00000000 __vectors_start
0000a000  w      .srom1	00000000 _reset_vector__
0000e092 g       .text	00000000 __ctors_start
0000e092  w      .text	00000000 __isr_12
0000e010  w      .text	00000000 __do_copy_data
0000a2ba g     F .srom1	00000396 read_byte
00001228 g       .bss	00000000 __bss_start
0000b752 g     F .srom1	0000006a memset
0000e03e g     F .text	0000004e main
0000e092  w      .text	00000000 __isr_13
00010000 g       .vectors	00000000 _vectors_end
00001238 g     O .bss	00000004 cur_seq
00001230 g     O .bss	00000008 count
00001340 g       .noinit	00000000 __noinit_start
0000dc00 g       .isr1	00000000 __isr_9
00001342 g       .noinit	00000000 __noinit_end
0000e00c  w      .text	00000000 __init_stack
0000e092 g       .text	00000000 __dtors_start
0000e092  w      .text	00000000 __isr_6
0000e092 g       .text	00000000 __ctors_end
00000132 g       *ABS*	00000000 __MPYS
00006200 g       *ABS*	00000000 __stack
0000e092  w      .text	00000000 __isr_1
00000228 g       .data	00000000 _edata
0000a176 g     F .srom1	0000008e CASU_update_authenticate
00001342 g       *ABS*	00000000 _end
00000208 g     O .data	00000020 cur_hash
0000dffe g       .srom2	00000000 __mac_leave
00000134 g       *ABS*	00000000 __MAC
0000de00 g     F .isr2	00000054 uart
0000e08c  w      .text	00000000 _endless_loop__
0000a292 g     F .srom1	00000028 send_buf
0000a04e g     F .srom1	0000002e CASU_jump_to_ER_routine
0000e010  w      .text	00000000 __low_level_init
00000200 g       .data	00000000 __data_start
00000120 g       *ABS*	00000000 __WDTCTL
0000b5ee g     F .srom1	00000010 hmac_core
0000b5fe g     F .srom1	0000005a hmac
0000013e g       *ABS*	00000000 __SUMEXT
0000e096 g     F .text	0000001e delayMicroseconds
00000200 g     O .data	00000004 dev_id



Disassembly of section .text:

0000e000 <__watchdog_support>:
    e000:	55 42 20 01 	mov.b	&0x0120,r5	
    e004:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08
    e008:	82 45 40 13 	mov	r5,	&0x1340	

0000e00c <__init_stack>:
    e00c:	31 40 00 62 	mov	#25088,	r1	;#0x6200

0000e010 <__do_copy_data>:
    e010:	3f 40 28 00 	mov	#40,	r15	;#0x0028
    e014:	0f 93       	tst	r15		
    e016:	08 24       	jz	$+18     	;abs 0xe028
    e018:	92 42 40 13 	mov	&0x1340,&0x0120	
    e01c:	20 01 
    e01e:	2f 83       	decd	r15		
    e020:	9f 4f 28 e1 	mov	-7896(r15),512(r15);0xe128(r15), 0x0200(r15)
    e024:	00 02 
    e026:	f8 23       	jnz	$-14     	;abs 0xe018

0000e028 <__do_clear_bss>:
    e028:	3f 40 18 01 	mov	#280,	r15	;#0x0118
    e02c:	0f 93       	tst	r15		
    e02e:	07 24       	jz	$+16     	;abs 0xe03e
    e030:	92 42 40 13 	mov	&0x1340,&0x0120	
    e034:	20 01 
    e036:	1f 83       	dec	r15		
    e038:	cf 43 28 12 	mov.b	#0,	4648(r15);r3 As==00, 0x1228(r15)
    e03c:	f9 23       	jnz	$-12     	;abs 0xe030

0000e03e <main>:

int main()
{
  /*this WTD stuff needs to go inside of wrapper*/
  // Switch off the WTD
  __eint();
    e03e:	32 d2       	eint			
  uint32_t *wdt = (uint32_t *)(WDTCTL_);
  *wdt = WDTPW | WDTHOLD;
    e040:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    e044:	20 01 
    e046:	82 43 22 01 	mov	#0,	&0x0122	;r3 As==00

  int i;
  const int iter = 5;

  // Set the LED
  initLed();
    e04a:	b0 12 b4 e0 	call	#0xe0b4	
    e04e:	3b 40 05 00 	mov	#5,	r11	;#0x0005
  // Enable interrupts: NO YOU CANT DO THAT HERE INTERRUPTS CAN ONLY BE ENABLED OR DISABLED WITHIN THE TCB  
 // __eint();
  //Sample application: Blink P3 for 200ms for 5 times;
  
  for (i=0; i<iter; i++) {
    P3OUT = 0x55;
    e052:	3a 40 19 00 	mov	#25,	r10	;#0x0019
    e056:	fa 40 55 00 	mov.b	#85,	0(r10)	;#0x0055, 0x0000(r10)
    e05a:	00 00 
    delayMicroseconds(20);
    e05c:	3f 40 14 00 	mov	#20,	r15	;#0x0014
    e060:	b0 12 96 e0 	call	#0xe096	
    P3OUT = 0xAA;
    e064:	fa 40 aa ff 	mov.b	#-86,	0(r10)	;#0xffaa, 0x0000(r10)
    e068:	00 00 
    delayMicroseconds(20);
    e06a:	3f 40 14 00 	mov	#20,	r15	;#0x0014
    e06e:	b0 12 96 e0 	call	#0xe096	
    e072:	3b 53       	add	#-1,	r11	;r3 As==11
  initLed();
  // Enable interrupts: NO YOU CANT DO THAT HERE INTERRUPTS CAN ONLY BE ENABLED OR DISABLED WITHIN THE TCB  
 // __eint();
  //Sample application: Blink P3 for 200ms for 5 times;
  
  for (i=0; i<iter; i++) {
    e074:	ee 23       	jnz	$-34     	;abs 0xe052
  //i'll keep it for now...
  
  while(1)
  {
    i++;
    delayMicroseconds(200000);
    e076:	3f 40 40 0d 	mov	#3392,	r15	;#0x0d40
    e07a:	b0 12 96 e0 	call	#0xe096	
    P3OUT = ~P3OUT;
    e07e:	3f 40 19 00 	mov	#25,	r15	;#0x0019
    e082:	6e 4f       	mov.b	@r15,	r14	
    e084:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    e086:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    e08a:	f5 3f       	jmp	$-20     	;abs 0xe076

0000e08c <__stop_progExec__>:
    e08c:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    e090:	fd 3f       	jmp	$-4      	;abs 0xe08c

0000e092 <__ctors_end>:
    e092:	30 40 26 e1 	br	#0xe126	

0000e096 <delayMicroseconds>:
    0xaf, 0x42, 0x75, 0xcb, 0x4c, 0x4d, 0x77, 0x39,
    0x14, 0x87, 0xb6, 0x6d, 0x4f, 0x37, 0x6d, 0xfc,
    0xea, 0x5f, 0x73, 0x84, 0x27, 0x9c, 0x7a, 0x89};

void delayMicroseconds(unsigned int delay)
{
    e096:	21 83       	decd	r1		
  volatile unsigned int j;
  for (j = 0; j < delay; j++);
    e098:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00, 0x0000(r1)
    e09c:	2e 41       	mov	@r1,	r14	
    e09e:	0e 9f       	cmp	r15,	r14	
    e0a0:	07 2c       	jc	$+16     	;abs 0xe0b0
    e0a2:	2e 41       	mov	@r1,	r14	
    e0a4:	1e 53       	inc	r14		
    e0a6:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    e0aa:	2e 41       	mov	@r1,	r14	
    e0ac:	0e 9f       	cmp	r15,	r14	
    e0ae:	f9 2b       	jnc	$-12     	;abs 0xe0a2
}
    e0b0:	21 53       	incd	r1		
    e0b2:	30 41       	ret			

0000e0b4 <initLed>:

void initLed() 
{
  P3DIR  =  0xFF;
    e0b4:	f2 43 1a 00 	mov.b	#-1,	&0x001a	;r3 As==11
  P3OUT  =  0x00;
    e0b8:	c2 43 19 00 	mov.b	#0,	&0x0019	;r3 As==00
}
    e0bc:	30 41       	ret			

0000e0be <CASU_secure_update>:
                   "\n\t");
}

/* Update routine in SW */
void CASU_secure_update(uint8_t *update_code, uint8_t *signature)
{
    e0be:	0b 12       	push	r11		
    e0c0:	0a 12       	push	r10		
    e0c2:	09 12       	push	r9		

  uint16_t new_ep_start = 0;
  uint16_t new_ep_end = 0;
  uint16_t update_code_size = *(uint16_t *)(update_code + OFFSET_SW_SIZE);
    e0c4:	2a 4f       	mov	@r15,	r10	
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    e0c6:	0d 43       	clr	r13		
  __asm__ volatile("br   r5"
                   "\n\t");
}

/* Update routine in SW */
void CASU_secure_update(uint8_t *update_code, uint8_t *signature)
    e0c8:	0c 4e       	mov	r14,	r12	
    e0ca:	0c 5d       	add	r13,	r12	
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    dst[i] = src[i];
    e0cc:	ed 4c d0 03 	mov.b	@r12,	976(r13);0x03d0(r13)
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    e0d0:	1d 53       	inc	r13		
    e0d2:	3d 90 20 00 	cmp	#32,	r13	;#0x0020
    e0d6:	f8 23       	jnz	$-14     	;abs 0xe0c8
  uint16_t update_code_size = *(uint16_t *)(update_code + OFFSET_SW_SIZE);
  // Copy input signature to SIG_RESP_ADDR:
  my_memcpy((uint8_t *)SIG_RESP_ADDR, signature, SIZE_SIGNATURE);

  // Check EP_START and decide where to write the update_code.
  if ((*(uint16_t *)EP_START >= ER_FIRST_SW_START) && (*(uint16_t *)EP_START < ER_SECOND_SW_START))
    e0d8:	1e 42 70 00 	mov	&0x0070,r14	
    e0dc:	3e 50 00 20 	add	#8192,	r14	;#0x2000
    e0e0:	3e 90 00 10 	cmp	#4096,	r14	;#0x1000
    e0e4:	03 2c       	jc	$+8      	;abs 0xe0ec
  {
    new_ep_start = ER_SECOND_SW_START;
    e0e6:	3b 40 00 f0 	mov	#-4096,	r11	;#0xf000
    e0ea:	02 3c       	jmp	$+6      	;abs 0xe0f0
  }
  else
  {
    new_ep_start = ER_FIRST_SW_START;
    e0ec:	3b 40 00 e0 	mov	#-8192,	r11	;#0xe000
  }
  new_ep_end = new_ep_start + update_code_size - 2;
    e0f0:	09 4a       	mov	r10,	r9	
    e0f2:	29 83       	decd	r9		
    e0f4:	09 5b       	add	r11,	r9	
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    e0f6:	1a 93       	cmp	#1,	r10	;r3 As==01
    e0f8:	0b 38       	jl	$+24     	;abs 0xe110
  __asm__ volatile("br   r5"
                   "\n\t");
}

/* Update routine in SW */
void CASU_secure_update(uint8_t *update_code, uint8_t *signature)
    e0fa:	0c 4b       	mov	r11,	r12	
    e0fc:	0c 5a       	add	r10,	r12	
    e0fe:	0e 4b       	mov	r11,	r14	
    e100:	0f 8b       	sub	r11,	r15	
    e102:	0d 4f       	mov	r15,	r13	
    e104:	0d 5e       	add	r14,	r13	
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    dst[i] = src[i];
    e106:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;0x0000(r14)
    e10a:	1e 53       	inc	r14		
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    e10c:	0e 9c       	cmp	r12,	r14	
    e10e:	f9 23       	jnz	$-12     	;abs 0xe102
  }
  new_ep_end = new_ep_start + update_code_size - 2;

  // Write the update_code at that location and update B_EP_START.
  my_memcpy((uint8_t *)new_ep_start, update_code, update_code_size);
  *(uint16_t *)B_EP_START = new_ep_start;
    e110:	82 4b cc fe 	mov	r11,	&0xfecc	
  *(uint16_t *)B_EP_END = new_ep_end;
    e114:	82 49 ce fe 	mov	r9,	&0xfece	

  // Set r4 as 1
  __asm__ volatile("mov    #1,  r4"
    e118:	14 43       	mov	#1,	r4	;r3 As==01
    __asm__ volatile("push r2" "\n\t");
    __asm__ volatile("mov    #1,  r4" "\n\t");
    __asm__ volatile("pop r4" "\n\t");*/

  // Call CASU:
  tcb_entry();
    e11a:	b0 12 00 a0 	call	#0xa000	
}
    e11e:	39 41       	pop	r9		
    e120:	3a 41       	pop	r10		
    e122:	3b 41       	pop	r11		
    e124:	30 41       	ret			

0000e126 <_unexpected_>:
    e126:	00 13       	reti			

Disassembly of section .srom1:

0000a000 <tcb_entry>:
  //__eint();
  /********** SETUP ON ENTRY **********/

  // CASU stuff and FIRST boot

  __asm__ volatile("mov    #0x1000,     r1"
    a000:	31 40 00 10 	mov	#4096,	r1	;#0x1000
                   "\n\t");
  __asm__ volatile("dint"
    a004:	32 c2       	dint			
                   "\n\t");

  if (*(uint8_t *)SCACHE_FLAG != 0)
    a006:	c2 93 df ff 	tst.b	&0xffdf	
    a00a:	02 24       	jz	$+6      	;abs 0xa010
  {
    CASU_update_install();
    a00c:	b0 12 7c a0 	call	#0xa07c	
  }

  __asm__ volatile("cmp.w #1, r4"
    a010:	14 93       	cmp	#1,	r4	;r3 As==01
                   "\n\t");
  __asm__ volatile("jeq    CASU_update_authenticate"
    a012:	b1 24       	jz	$+356    	;abs 0xa176

 // CCTL0 = CCIE;                            // CCR0 interrupt enabled
 // CCR0  = 1000;
 // TACTL = TASSEL_2 + MC_1 + ID_3;    
  // Init UART
  UART_BAUD = BAUD;
    a014:	b2 40 58 14 	mov	#5208,	&0x0082	;#0x1458
    a018:	82 00 
  UART_CTL = UART_EN | UART_IEN_RX;; 
    a01a:	f2 40 11 00 	mov.b	#17,	&0x0080	;#0x0011
    a01e:	80 00 

  // P3DIR = 0xFF;
  // P3OUT = 0xFF;

  __asm__ volatile("jmp    CASU_jump_to_ER_routine_init"
    a020:	01 3c       	jmp	$+4      	;abs 0xa024
                   "\n\t");
}
    a022:	30 41       	ret			

0000a024 <CASU_jump_to_ER_routine_init>:

__attribute__((section(".do_mac.body"))) void CASU_jump_to_ER_routine_init()
{

  // Read the ER start address from EP_START and store in r5
  __asm__ volatile("mov    #0x0070,   r5"
    a024:	35 40 70 00 	mov	#112,	r5	;#0x0070
                   "\n\t");
  __asm__ volatile("mov    @(r5),     r5"
    a028:	25 45       	mov	@r5,	r5	
                   "\n\t");

  // Set the Stack Pointer to ER Stack before leaving CASU
  __asm__ volatile("mov    #0x6200,     r1"
    a02a:	31 40 00 62 	mov	#25088,	r1	;#0x6200
                   "\n\t");
  __asm__ volatile("clr    r3"
    a02e:	03 43       	nop			
                   "\n\t");
  __asm__ volatile("clr    r4"
    a030:	04 43       	clr	r4		
                   "\n\t");
  __asm__ volatile("clr    r6"
    a032:	06 43       	clr	r6		
                   "\n\t");
  __asm__ volatile("clr    r7"
    a034:	07 43       	clr	r7		
                   "\n\t");
  __asm__ volatile("clr    r8"
    a036:	08 43       	clr	r8		
                   "\n\t");
  __asm__ volatile("clr    r9"
    a038:	09 43       	clr	r9		
                   "\n\t");
  __asm__ volatile("clr    r10"
    a03a:	0a 43       	clr	r10		
                   "\n\t");
  __asm__ volatile("clr    r11"
    a03c:	0b 43       	clr	r11		
                   "\n\t");
  __asm__ volatile("clr    r12"
    a03e:	0c 43       	clr	r12		
                   "\n\t");
  __asm__ volatile("clr    r13"
    a040:	0d 43       	clr	r13		
                   "\n\t");
  __asm__ volatile("clr    r14"
    a042:	0e 43       	clr	r14		
                   "\n\t");
  __asm__ volatile("clr    r15"
    a044:	0f 43       	clr	r15		
                   "\n\t");

  // Jump to CASU_exit
  __eint();
    a046:	32 d2       	eint			
  __asm__ volatile("br      #__mac_leave"
    a048:	30 40 fe df 	br	#0xdffe	
                   "\n\t");
}
    a04c:	30 41       	ret			

0000a04e <CASU_jump_to_ER_routine>:

__attribute__((section(".do_mac.body"))) void CASU_jump_to_ER_routine()
{

  // Read the ER start address from EP_START and store in r5
  __asm__ volatile("mov    #0x0070,   r5"
    a04e:	35 40 70 00 	mov	#112,	r5	;#0x0070
                   "\n\t");
  __asm__ volatile("mov    @(r5),     r5"
    a052:	25 45       	mov	@r5,	r5	
                   "\n\t");
  // Jump to the starting of the software. The header size is 36
  __asm__ volatile("add    #36,     r5"
    a054:	35 50 24 00 	add	#36,	r5	;#0x0024
                   "\n\t");

  // Set the Stack Pointer to ER Stack before leaving CASU
  __asm__ volatile("mov    #0x6200,     r1"
    a058:	31 40 00 62 	mov	#25088,	r1	;#0x6200
                   "\n\t");
  __asm__ volatile("clr    r3"
    a05c:	03 43       	nop			
                   "\n\t");
  __asm__ volatile("clr    r4"
    a05e:	04 43       	clr	r4		
                   "\n\t");
  __asm__ volatile("clr    r6"
    a060:	06 43       	clr	r6		
                   "\n\t");
  __asm__ volatile("clr    r7"
    a062:	07 43       	clr	r7		
                   "\n\t");
  __asm__ volatile("clr    r8"
    a064:	08 43       	clr	r8		
                   "\n\t");
  __asm__ volatile("clr    r9"
    a066:	09 43       	clr	r9		
                   "\n\t");
  __asm__ volatile("clr    r10"
    a068:	0a 43       	clr	r10		
                   "\n\t");
  __asm__ volatile("clr    r11"
    a06a:	0b 43       	clr	r11		
                   "\n\t");
  __asm__ volatile("clr    r12"
    a06c:	0c 43       	clr	r12		
                   "\n\t");
  __asm__ volatile("clr    r13"
    a06e:	0d 43       	clr	r13		
                   "\n\t");
  __asm__ volatile("clr    r14"
    a070:	0e 43       	clr	r14		
                   "\n\t");
  __asm__ volatile("clr    r15"
    a072:	0f 43       	clr	r15		
                   "\n\t");

  // Jump to CASU_exit
  __eint();
    a074:	32 d2       	eint			
  __asm__ volatile("br      #__mac_leave"
    a076:	30 40 fe df 	br	#0xdffe	
                   "\n\t");
}
    a07a:	30 41       	ret			

0000a07c <CASU_update_install>:
  // Otherwise, jump to CASU_jump_to_ER_routine_init()
  CASU_jump_to_ER_routine_init();
}

__attribute__((section(".do_mac.body"))) void CASU_update_install()
{
    a07c:	0b 12       	push	r11		
    a07e:	31 50 be ff 	add	#-66,	r1	;#0xffbe

  // Set SCACHE_FLAG to 1
  if (*(uint8_t *)SCACHE_FLAG == 0)
    a082:	c2 93 df ff 	tst.b	&0xffdf	
    a086:	02 20       	jnz	$+6      	;abs 0xa08c
  {
    *(uint8_t *)SCACHE_FLAG = 1;
    a088:	d2 43 df ff 	mov.b	#1,	&0xffdf	;r3 As==01
  }

  // Check whether EP_START == B_EP_START, if not, copy B_EP_START to EP_START
  if (*(uint16_t *)EP_START != (*(uint16_t *)B_EP_START))
    a08c:	1f 42 cc fe 	mov	&0xfecc,r15	
    a090:	1f 92 70 00 	cmp	&0x0070,r15	
    a094:	05 24       	jz	$+12     	;abs 0xa0a0
  {
    *(uint16_t *)EP_START = *(uint16_t *)B_EP_START;
    a096:	82 4f 70 00 	mov	r15,	&0x0070	
    *(uint16_t *)EP_END = *(uint16_t *)B_EP_END;
    a09a:	92 42 ce fe 	mov	&0xfece,&0xffdc	
    a09e:	dc ff 
  }

  // Copy new IVT (from software at B_EP_START) to SCACHE_IVT and make sure Reset handler is 0xA000
  memcpy((uint8_t *)SCACHE_IVT, (uint8_t *)(*(uint16_t *)B_EP_END) + 2 - SIZE_IVT, SIZE_IVT);
    a0a0:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a0a4:	1e 42 ce fe 	mov	&0xfece,r14	
    a0a8:	3e 50 e2 ff 	add	#-30,	r14	;#0xffe2
    a0ac:	3f 40 e0 ff 	mov	#-32,	r15	;#0xffe0
    a0b0:	b0 12 58 b6 	call	#0xb658	

  // Compute response and store to SIG_RESP_ADDR
  uint8_t key[SIZE_KEY] = {0};
    a0b4:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a0b8:	0e 43       	clr	r14		
    a0ba:	0f 41       	mov	r1,	r15	
    a0bc:	b0 12 52 b7 	call	#0xb752	
  memcpy(key, (uint8_t *)KEY_ADDR, SIZE_KEY);
    a0c0:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a0c4:	3e 40 00 6a 	mov	#27136,	r14	;#0x6a00
    a0c8:	0f 41       	mov	r1,	r15	
    a0ca:	b0 12 58 b6 	call	#0xb658	
  uint8_t response_body[SIZE_VER_INFO + SIZE_NONCE] = {0};
    a0ce:	0b 41       	mov	r1,	r11	
    a0d0:	3b 50 20 00 	add	#32,	r11	;#0x0020
    a0d4:	3d 40 22 00 	mov	#34,	r13	;#0x0022
    a0d8:	0e 43       	clr	r14		
    a0da:	0f 4b       	mov	r11,	r15	
    a0dc:	b0 12 52 b7 	call	#0xb752	
  *(uint16_t *)response_body = *(uint16_t *)((uint8_t *)(*(uint16_t *)B_EP_START) + OFFSET_VER_INFO);
    a0e0:	3e 40 cc fe 	mov	#-308,	r14	;#0xfecc
    a0e4:	2f 4e       	mov	@r14,	r15	
    a0e6:	91 4f 02 00 	mov	2(r15),	32(r1)	;0x0002(r15), 0x0020(r1)
    a0ea:	20 00 
  memcpy(response_body + SIZE_VER_INFO, (uint8_t *)(*(uint16_t *)B_EP_START) + OFFSET_NONCE, SIZE_NONCE);
    a0ec:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a0f0:	2e 4e       	mov	@r14,	r14	
    a0f2:	2e 52       	add	#4,	r14	;r2 As==10
    a0f4:	0f 41       	mov	r1,	r15	
    a0f6:	3f 50 22 00 	add	#34,	r15	;#0x0022
    a0fa:	b0 12 58 b6 	call	#0xb658	
  hmac((uint8_t *)SIG_RESP_ADDR, (uint8_t *)key, (uint32_t)SIZE_KEY, response_body, (uint32_t)(SIZE_VER_INFO + SIZE_NONCE));
    a0fe:	03 12       	push	#0		;r3 As==00
    a100:	30 12 22 00 	push	#34		;#0x0022
    a104:	0b 12       	push	r11		
    a106:	3c 40 20 00 	mov	#32,	r12	;#0x0020
    a10a:	0d 43       	clr	r13		
    a10c:	0e 41       	mov	r1,	r14	
    a10e:	3e 50 06 00 	add	#6,	r14	;#0x0006
    a112:	3f 40 d0 03 	mov	#976,	r15	;#0x03d0
    a116:	b0 12 fe b5 	call	#0xb5fe	
    a11a:	31 50 06 00 	add	#6,	r1	;#0x0006

  // Set SCACHE_FLAG to 0
  *(uint8_t *)SCACHE_FLAG = 0;
    a11e:	c2 43 df ff 	mov.b	#0,	&0xffdf	;r3 As==00

  CASU_jump_to_ER_routine();
    a122:	b0 12 4e a0 	call	#0xa04e	
}
    a126:	31 50 42 00 	add	#66,	r1	;#0x0042
    a12a:	3b 41       	pop	r11		
    a12c:	30 41       	ret			

0000a12e <secure_memcmp>:
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.body"))) int secure_memcmp(const uint8_t *s1, const uint8_t *s2, int size)
{
    a12e:	0b 12       	push	r11		
    a130:	0a 12       	push	r10		
    a132:	09 12       	push	r9		
    a134:	08 12       	push	r8		
  int res = 0;
  int first = 1;
  for (int i = 0; i < size; i++)
    a136:	1d 93       	cmp	#1,	r13	;r3 As==01
    a138:	18 38       	jl	$+50     	;abs 0xa16a
    a13a:	0b 4f       	mov	r15,	r11	
    a13c:	0c 43       	clr	r12		
}

__attribute__((section(".do_mac.body"))) int secure_memcmp(const uint8_t *s1, const uint8_t *s2, int size)
{
  int res = 0;
  int first = 1;
    a13e:	1a 43       	mov	#1,	r10	;r3 As==01
                   "\n\t");
}

__attribute__((section(".do_mac.body"))) int secure_memcmp(const uint8_t *s1, const uint8_t *s2, int size)
{
  int res = 0;
    a140:	0f 43       	clr	r15		
  int first = 1;
  for (int i = 0; i < size; i++)
  {
    if (first == 1 && s1[i] > s2[i])
    a142:	1a 93       	cmp	#1,	r10	;r3 As==01
    a144:	0c 20       	jnz	$+26     	;abs 0xa15e
    a146:	ee 9b 00 00 	cmp.b	@r11,	0(r14)	;0x0000(r14)
    a14a:	04 28       	jnc	$+10     	;abs 0xa154
    {
      res = 1;
      first = 0;
    }
    else if (first == 1 && s1[i] < s2[i])
    a14c:	eb 9e 00 00 	cmp.b	@r14,	0(r11)	;0x0000(r11)
    a150:	04 28       	jnc	$+10     	;abs 0xa15a
    a152:	05 3c       	jmp	$+12     	;abs 0xa15e
  for (int i = 0; i < size; i++)
  {
    if (first == 1 && s1[i] > s2[i])
    {
      res = 1;
      first = 0;
    a154:	0a 43       	clr	r10		
  int first = 1;
  for (int i = 0; i < size; i++)
  {
    if (first == 1 && s1[i] > s2[i])
    {
      res = 1;
    a156:	1f 43       	mov	#1,	r15	;r3 As==01
    a158:	02 3c       	jmp	$+6      	;abs 0xa15e
      first = 0;
    }
    else if (first == 1 && s1[i] < s2[i])
    {
      res = -1;
      first = 0;
    a15a:	0a 43       	clr	r10		
      res = 1;
      first = 0;
    }
    else if (first == 1 && s1[i] < s2[i])
    {
      res = -1;
    a15c:	3f 43       	mov	#-1,	r15	;r3 As==11

__attribute__((section(".do_mac.body"))) int secure_memcmp(const uint8_t *s1, const uint8_t *s2, int size)
{
  int res = 0;
  int first = 1;
  for (int i = 0; i < size; i++)
    a15e:	1c 53       	inc	r12		
    a160:	1b 53       	inc	r11		
    a162:	1e 53       	inc	r14		
    a164:	0c 9d       	cmp	r13,	r12	
    a166:	ed 23       	jnz	$-36     	;abs 0xa142
    a168:	01 3c       	jmp	$+4      	;abs 0xa16c
                   "\n\t");
}

__attribute__((section(".do_mac.body"))) int secure_memcmp(const uint8_t *s1, const uint8_t *s2, int size)
{
  int res = 0;
    a16a:	0f 43       	clr	r15		
      res = -1;
      first = 0;
    }
  }
  return res;
}
    a16c:	38 41       	pop	r8		
    a16e:	39 41       	pop	r9		
    a170:	3a 41       	pop	r10		
    a172:	3b 41       	pop	r11		
    a174:	30 41       	ret			

0000a176 <CASU_update_authenticate>:
  }
  UART_STAT = UART_RX_PND;
}

__attribute__((section(".do_mac.body"))) void CASU_update_authenticate()
{
    a176:	31 50 c0 ff 	add	#-64,	r1	;#0xffc0
  uint8_t key[SIZE_KEY] = {0};
    a17a:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a17e:	0e 43       	clr	r14		
    a180:	0f 41       	mov	r1,	r15	
    a182:	b0 12 52 b7 	call	#0xb752	

  memcpy(key, (uint8_t *)KEY_ADDR, SIZE_KEY);
    a186:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a18a:	3e 40 00 6a 	mov	#27136,	r14	;#0x6a00
    a18e:	0f 41       	mov	r1,	r15	
    a190:	b0 12 58 b6 	call	#0xb658	

  /* Work around for version number of existing software */
  // Check if the version number is greater than the previous one.
  if (*(uint16_t *)((uint8_t *)B_EP_START + OFFSET_VER_INFO) <= *(uint16_t *)((uint8_t *)EXISTING_SW_VERSION))
    a194:	92 92 ce fe 	cmp	&0xfece,&0xffd8	
    a198:	d8 ff 
    a19a:	02 28       	jnc	$+6      	;abs 0xa1a0
  {
    CASU_jump_to_ER_routine_init();
    a19c:	b0 12 24 a0 	call	#0xa024	
  }

  // Compute HMAC on the bEP.
  uint8_t signature[SIZE_SIGNATURE] = {0};
    a1a0:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a1a4:	0e 43       	clr	r14		
    a1a6:	0f 41       	mov	r1,	r15	
    a1a8:	3f 50 20 00 	add	#32,	r15	;#0x0020
    a1ac:	b0 12 52 b7 	call	#0xb752	
  uint8_t *bEP_min = (uint8_t *)(*((uint16_t *)B_EP_START));
    a1b0:	1d 42 cc fe 	mov	&0xfecc,r13	
  uint16_t bEP_size = ((*(uint16_t *)B_EP_END) - (*(uint16_t *)B_EP_START)) + 2;
    a1b4:	1c 42 ce fe 	mov	&0xfece,r12	
    a1b8:	2c 53       	incd	r12		

  hmac((uint8_t *)signature, (uint8_t *)key, (uint32_t)SIZE_KEY, (uint8_t *)bEP_min, (uint32_t)bEP_size);
    a1ba:	0e 4c       	mov	r12,	r14	
    a1bc:	0e 8d       	sub	r13,	r14	
    a1be:	0f 43       	clr	r15		
    a1c0:	0f 12       	push	r15		
    a1c2:	0e 12       	push	r14		
    a1c4:	0d 12       	push	r13		
    a1c6:	3c 40 20 00 	mov	#32,	r12	;#0x0020
    a1ca:	0d 43       	clr	r13		
    a1cc:	0e 41       	mov	r1,	r14	
    a1ce:	3e 50 06 00 	add	#6,	r14	;#0x0006
    a1d2:	0f 41       	mov	r1,	r15	
    a1d4:	3f 50 26 00 	add	#38,	r15	;#0x0026
    a1d8:	b0 12 fe b5 	call	#0xb5fe	
    a1dc:	31 50 06 00 	add	#6,	r1	;#0x0006

  // Check if signature == SIG_RESP_ADDR. If yes, jump to CASU_update_install()
  if (secure_memcmp(signature, (uint8_t *)SIG_RESP_ADDR, sizeof(signature)) == 0)
    a1e0:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a1e4:	3e 40 d0 03 	mov	#976,	r14	;#0x03d0
    a1e8:	0f 41       	mov	r1,	r15	
    a1ea:	3f 50 20 00 	add	#32,	r15	;#0x0020
    a1ee:	b0 12 2e a1 	call	#0xa12e	
    a1f2:	0f 93       	tst	r15		
    a1f4:	02 20       	jnz	$+6      	;abs 0xa1fa
  {
    CASU_update_install();
    a1f6:	b0 12 7c a0 	call	#0xa07c	
  }

  // Otherwise, jump to CASU_jump_to_ER_routine_init()
  CASU_jump_to_ER_routine_init();
    a1fa:	b0 12 24 a0 	call	#0xa024	
}
    a1fe:	31 50 40 00 	add	#64,	r1	;#0x0040
    a202:	30 41       	ret			

0000a204 <recv_buf>:
  tcb_entry();
}

/************ UART COMS ************/
__attribute__((section(".do_mac.lib"))) void recv_buf(uint8_t *rx_data, uint16_t size)
{
    a204:	0b 12       	push	r11		
    a206:	0a 12       	push	r10		
    a208:	09 12       	push	r9		
    a20a:	09 4f       	mov	r15,	r9	
    a20c:	0a 4e       	mov	r14,	r10	
  // P3OUT ^= 0x40;
  unsigned int i = 0, j;
  unsigned long time = 0;
  while (i < size && time != UART_TIMEOUT)
    a20e:	0e 93       	tst	r14		
    a210:	28 20       	jnz	$+82     	;abs 0xa262
    a212:	3b 3c       	jmp	$+120    	;abs 0xa28a

#if IS_SIM == NOT_SIM
    // wait while rx buffer is empty         // implementation only
    while ((UART_STAT & UART_RX_PND) != UART_RX_PND && time != UART_TIMEOUT)
    {
      time++;
    a214:	1e 53       	inc	r14		
    a216:	0f 63       	adc	r15		
  while (i < size && time != UART_TIMEOUT)
  {

#if IS_SIM == NOT_SIM
    // wait while rx buffer is empty         // implementation only
    while ((UART_STAT & UART_RX_PND) != UART_RX_PND && time != UART_TIMEOUT)
    a218:	5d 42 81 00 	mov.b	&0x0081,r13	
    a21c:	3d f0 10 00 	and	#16,	r13	;#0x0010
    a220:	06 20       	jnz	$+14     	;abs 0xa22e
    a222:	3e 90 fe 7f 	cmp	#32766,	r14	;#0x7ffe
    a226:	f6 23       	jnz	$-18     	;abs 0xa214
    a228:	0f 93       	tst	r15		
    a22a:	f4 23       	jnz	$-22     	;abs 0xa214
    a22c:	27 3c       	jmp	$+80     	;abs 0xa27c
    {
      time++;
    }
    UART_STAT |= UART_RX_PND;
    a22e:	3d 40 81 00 	mov	#129,	r13	;#0x0081
    a232:	6b 4d       	mov.b	@r13,	r11	
    a234:	7b d0 10 00 	bis.b	#16,	r11	;#0x0010
    a238:	cd 4b 00 00 	mov.b	r11,	0(r13)	;0x0000(r13)
#endif

    if (time == UART_TIMEOUT)
    a23c:	3e 90 fe 7f 	cmp	#32766,	r14	;#0x7ffe
    a240:	02 20       	jnz	$+6      	;abs 0xa246
    a242:	0f 93       	tst	r15		
    a244:	22 24       	jz	$+70     	;abs 0xa28a
    {
      break;
    }
    else
    {
      rx_data[i] = UART_RXD;
    a246:	5b 42 85 00 	mov.b	&0x0085,r11	
  // Call CASU:
  tcb_entry();
}

/************ UART COMS ************/
__attribute__((section(".do_mac.lib"))) void recv_buf(uint8_t *rx_data, uint16_t size)
    a24a:	0d 49       	mov	r9,	r13	
    a24c:	0d 5c       	add	r12,	r13	
    {
      break;
    }
    else
    {
      rx_data[i] = UART_RXD;
    a24e:	cd 4b 00 00 	mov.b	r11,	0(r13)	;0x0000(r13)
    a252:	3d 40 64 00 	mov	#100,	r13	;#0x0064
    a256:	3d 53       	add	#-1,	r13	;r3 As==11

#if IS_SIM == NOT_SIM
      // implementation only
      for (j = 0; j < DELAY; j++)
    a258:	fe 23       	jnz	$-2      	;abs 0xa256
      {
      } // wait for buffer to clear before reading next char
#endif

      i++;
    a25a:	1c 53       	inc	r12		
__attribute__((section(".do_mac.lib"))) void recv_buf(uint8_t *rx_data, uint16_t size)
{
  // P3OUT ^= 0x40;
  unsigned int i = 0, j;
  unsigned long time = 0;
  while (i < size && time != UART_TIMEOUT)
    a25c:	0c 9a       	cmp	r10,	r12	
    a25e:	04 20       	jnz	$+10     	;abs 0xa268
    a260:	14 3c       	jmp	$+42     	;abs 0xa28a

/************ UART COMS ************/
__attribute__((section(".do_mac.lib"))) void recv_buf(uint8_t *rx_data, uint16_t size)
{
  // P3OUT ^= 0x40;
  unsigned int i = 0, j;
    a262:	0c 43       	clr	r12		
  unsigned long time = 0;
    a264:	0e 43       	clr	r14		
    a266:	0f 43       	clr	r15		
  while (i < size && time != UART_TIMEOUT)
  {

#if IS_SIM == NOT_SIM
    // wait while rx buffer is empty         // implementation only
    while ((UART_STAT & UART_RX_PND) != UART_RX_PND && time != UART_TIMEOUT)
    a268:	5d 42 81 00 	mov.b	&0x0081,r13	
    a26c:	3d f0 10 00 	and	#16,	r13	;#0x0010
    a270:	de 23       	jnz	$-66     	;abs 0xa22e
    a272:	3e 90 fe 7f 	cmp	#32766,	r14	;#0x7ffe
    a276:	ce 23       	jnz	$-98     	;abs 0xa214
    a278:	0f 93       	tst	r15		
    a27a:	cc 23       	jnz	$-102    	;abs 0xa214
    {
      time++;
    }
    UART_STAT |= UART_RX_PND;
    a27c:	3f 40 81 00 	mov	#129,	r15	;#0x0081
    a280:	6e 4f       	mov.b	@r15,	r14	
    a282:	7e d0 10 00 	bis.b	#16,	r14	;#0x0010
    a286:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)

      i++;
    }
  }
  // P3OUT ^= 0x40;
}
    a28a:	39 41       	pop	r9		
    a28c:	3a 41       	pop	r10		
    a28e:	3b 41       	pop	r11		
    a290:	30 41       	ret			

0000a292 <send_buf>:
{

  //__asm__ volatile("dint" "\n\t");
  // P3OUT ^= 0x20;
  unsigned int i, j;
  for (i = 0; i < size; i++)
    a292:	0e 93       	tst	r14		
    a294:	11 24       	jz	$+36     	;abs 0xa2b8
    a296:	0c 43       	clr	r12		
  {
#if IS_SIM == NOT_SIM
    // delay until tx buffer is empty // implementation only
    while (UART_STAT & UART_TX_FULL)
    a298:	5d 42 81 00 	mov.b	&0x0081,r13	
    a29c:	3d f2       	and	#8,	r13	;r2 As==11
    a29e:	fc 23       	jnz	$-6      	;abs 0xa298
    }
  }
  // P3OUT ^= 0x40;
}

__attribute__((section(".do_mac.lib"))) void send_buf(uint8_t *tx_data, uint16_t size)
    a2a0:	0d 4f       	mov	r15,	r13	
    a2a2:	0d 5c       	add	r12,	r13	
    // delay until tx buffer is empty // implementation only
    while (UART_STAT & UART_TX_FULL)
      ;
#endif

    UART_TXD = tx_data[i];
    a2a4:	6d 4d       	mov.b	@r13,	r13	
    a2a6:	c2 4d 84 00 	mov.b	r13,	&0x0084	
    a2aa:	3d 40 64 00 	mov	#100,	r13	;#0x0064
    a2ae:	3d 53       	add	#-1,	r13	;r3 As==11

#if IS_SIM == NOT_SIM
    // only implementation
    for (j = 0; j < DELAY; j++)
    a2b0:	fe 23       	jnz	$-2      	;abs 0xa2ae
{

  //__asm__ volatile("dint" "\n\t");
  // P3OUT ^= 0x20;
  unsigned int i, j;
  for (i = 0; i < size; i++)
    a2b2:	1c 53       	inc	r12		
    a2b4:	0c 9e       	cmp	r14,	r12	
    a2b6:	f0 23       	jnz	$-30     	;abs 0xa298
    a2b8:	30 41       	ret			

0000a2ba <read_byte>:
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
{
    a2ba:	0b 12       	push	r11		
    a2bc:	0a 12       	push	r10		
    a2be:	09 12       	push	r9		
    a2c0:	08 12       	push	r8		
    a2c2:	07 12       	push	r7		
    a2c4:	31 50 1c ff 	add	#-228,	r1	;#0xff1c
  struct req_msg req_msg;
  struct att_req_msg att_req_msg;
  uint8_t rxbyte = 0;
    a2c8:	c1 43 2d 00 	mov.b	#0,	45(r1)	;r3 As==00, 0x002d(r1)
  uint8_t key[SIZE_KEY] = {0};
  while (rxbyte != END_BYTE)
  {
    recv_buf(&rxbyte, sizeof(rxbyte));
    a2cc:	1e 43       	mov	#1,	r14	;r3 As==01
    a2ce:	0f 41       	mov	r1,	r15	
    a2d0:	3f 50 2d 00 	add	#45,	r15	;#0x002d
    a2d4:	b0 12 04 a2 	call	#0xa204	
    // P3OUT = ~P3OUT;

    if (rxbyte != END_BYTE)
    a2d8:	5e 41 2d 00 	mov.b	45(r1),	r14	;0x002d(r1)
    a2dc:	7e 90 7d 00 	cmp.b	#125,	r14	;#0x007d
    a2e0:	08 24       	jz	$+18     	;abs 0xa2f2
    {
      rxdata[rx_end++] = rxbyte;
    a2e2:	5d 42 28 12 	mov.b	&0x1228,r13	
    a2e6:	4f 4d       	mov.b	r13,	r15	
    a2e8:	cf 4e 3c 12 	mov.b	r14,	4668(r15);0x123c(r15)
    a2ec:	5d 53       	inc.b	r13		
    a2ee:	c2 4d 28 12 	mov.b	r13,	&0x1228	
      if (rx_end == RING_BUF_SIZE)
      {
        rx_end = 0;
      }
    }
    send_buf(&rxbyte, sizeof(rxbyte));
    a2f2:	1e 43       	mov	#1,	r14	;r3 As==01
    a2f4:	0f 41       	mov	r1,	r15	
    a2f6:	3f 50 2d 00 	add	#45,	r15	;#0x002d
    a2fa:	b0 12 92 a2 	call	#0xa292	
{
  struct req_msg req_msg;
  struct att_req_msg att_req_msg;
  uint8_t rxbyte = 0;
  uint8_t key[SIZE_KEY] = {0};
  while (rxbyte != END_BYTE)
    a2fe:	f1 90 7d 00 	cmp.b	#125,	45(r1)	;#0x007d, 0x002d(r1)
    a302:	2d 00 
    a304:	e3 23       	jnz	$-56     	;abs 0xa2cc
      }
    }
    send_buf(&rxbyte, sizeof(rxbyte));
  }
  // send_buf(&rxdata[0], sizeof(RING_BUF_SIZE));
  switch (rxdata[rx_start])
    a306:	5e 42 2a 12 	mov.b	&0x122a,r14	
    a30a:	4f 4e       	mov.b	r14,	r15	
    a30c:	5d 4f 3c 12 	mov.b	4668(r15),r13	;0x123c(r15)
    a310:	4d 93       	tst.b	r13		
    a312:	06 24       	jz	$+14     	;abs 0xa320
    a314:	6d 93       	cmp.b	#2,	r13	;r3 As==10
    a316:	02 24       	jz	$+6      	;abs 0xa31c
    a318:	30 40 3a a6 	br	#0xa63a	
    a31c:	30 40 8a a5 	br	#0xa58a	
  {
  case MSG_TYPE_REQ: // verify state
    if (rx_start > rx_end)
    a320:	58 42 28 12 	mov.b	&0x1228,r8	
    a324:	48 9e       	cmp.b	r14,	r8	
    a326:	23 2c       	jc	$+72     	;abs 0xa36e
    {
      my_memcpy((uint8_t *)&att_req_msg, &rxdata[rx_start], RING_BUF_SIZE - rx_start); 
    a328:	3a 40 00 01 	mov	#256,	r10	;#0x0100
    a32c:	0a 8f       	sub	r15,	r10	
    a32e:	4e 4e       	mov.b	r14,	r14	
    a330:	09 4e       	mov	r14,	r9	
    a332:	39 50 3c 12 	add	#4668,	r9	;#0x123c
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a336:	1a 93       	cmp	#1,	r10	;r3 As==01
    a338:	0a 38       	jl	$+22     	;abs 0xa34e
    a33a:	0f 43       	clr	r15		
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a33c:	0c 41       	mov	r1,	r12	
    a33e:	0c 5f       	add	r15,	r12	
    a340:	0d 49       	mov	r9,	r13	
    a342:	0d 5f       	add	r15,	r13	
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    dst[i] = src[i];
    a344:	ec 4d 00 00 	mov.b	@r13,	0(r12)	;0x0000(r12)
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a348:	1f 53       	inc	r15		
    a34a:	0f 9a       	cmp	r10,	r15	
    a34c:	f7 23       	jnz	$-16     	;abs 0xa33c
  {
  case MSG_TYPE_REQ: // verify state
    if (rx_start > rx_end)
    {
      my_memcpy((uint8_t *)&att_req_msg, &rxdata[rx_start], RING_BUF_SIZE - rx_start); 
      my_memcpy(((uint8_t *)&att_req_msg + RING_BUF_SIZE - rx_start), &rxdata[0], rx_end + 1);
    a34e:	0c 41       	mov	r1,	r12	
    a350:	0c 8e       	sub	r14,	r12	
    a352:	3c 50 00 01 	add	#256,	r12	;#0x0100
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a356:	4d 48       	mov.b	r8,	r13	
    a358:	1d 53       	inc	r13		
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a35a:	0f 43       	clr	r15		
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a35c:	0e 4c       	mov	r12,	r14	
    a35e:	0e 5f       	add	r15,	r14	
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    dst[i] = src[i];
    a360:	de 4f 3c 12 	mov.b	4668(r15),0(r14)	;0x123c(r15), 0x0000(r14)
    a364:	00 00 
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a366:	1f 53       	inc	r15		
    a368:	0f 9d       	cmp	r13,	r15	
    a36a:	f8 23       	jnz	$-14     	;abs 0xa35c
    a36c:	14 3c       	jmp	$+42     	;abs 0xa396
      my_memcpy((uint8_t *)&att_req_msg, &rxdata[rx_start], RING_BUF_SIZE - rx_start); 
      my_memcpy(((uint8_t *)&att_req_msg + RING_BUF_SIZE - rx_start), &rxdata[0], rx_end + 1);
    }
    else
    {
      my_memcpy((uint8_t *)&att_req_msg, &rxdata[rx_start], rx_end - rx_start + 1);
    a36e:	4a 48       	mov.b	r8,	r10	
    a370:	0a 8f       	sub	r15,	r10	
    a372:	4e 4e       	mov.b	r14,	r14	
    a374:	3e 50 3c 12 	add	#4668,	r14	;#0x123c
    a378:	0f 4a       	mov	r10,	r15	
    a37a:	1f 53       	inc	r15		
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a37c:	1f 93       	cmp	#1,	r15	;r3 As==01
    a37e:	0b 38       	jl	$+24     	;abs 0xa396
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a380:	0a 4f       	mov	r15,	r10	
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a382:	0f 43       	clr	r15		
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a384:	0c 41       	mov	r1,	r12	
    a386:	0c 5f       	add	r15,	r12	
    a388:	0d 4e       	mov	r14,	r13	
    a38a:	0d 5f       	add	r15,	r13	
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    dst[i] = src[i];
    a38c:	ec 4d 00 00 	mov.b	@r13,	0(r12)	;0x0000(r12)
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a390:	1f 53       	inc	r15		
    a392:	0f 9a       	cmp	r10,	r15	
    a394:	f7 23       	jnz	$-16     	;abs 0xa384
    else
    {
      my_memcpy((uint8_t *)&att_req_msg, &rxdata[rx_start], rx_end - rx_start + 1);
    }
   // send_buf((uint8_t *)&att_req_msg, sizeof(att_req_msg));
    memset(rxdata, 0, sizeof(rxdata));
    a396:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    a39a:	0e 43       	clr	r14		
    a39c:	3f 40 3c 12 	mov	#4668,	r15	;#0x123c
    a3a0:	b0 12 52 b7 	call	#0xb752	
    rx_start = 0;
    a3a4:	c2 43 2a 12 	mov.b	#0,	&0x122a	;r3 As==00
    rx_end = 0;
    a3a8:	c2 43 28 12 	mov.b	#0,	&0x1228	;r3 As==00
  //  send_buf((uint8_t *)&att_req_msg.hash, SIZE_HASH);
   // send_buf(&sendF, sizeof(sendF));
  //  send_buf((uint8_t *)&att_req_msg.cur_time, sizeof(uint32_t));
   // send_buf(&sendF, sizeof(sendF));

    uint8_t hash_res[SIZE_HASH] = {0};
    a3ac:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a3b0:	0e 43       	clr	r14		
    a3b2:	0f 41       	mov	r1,	r15	
    a3b4:	3f 50 4e 00 	add	#78,	r15	;#0x004e
    a3b8:	b0 12 52 b7 	call	#0xb752	
    if (cur_hash_idx > att_req_msg.hash_idx) // line 8
    a3bc:	5e 41 05 00 	mov.b	5(r1),	r14	;0x0005(r1)
    a3c0:	5f 41 06 00 	mov.b	6(r1),	r15	;0x0006(r1)
    a3c4:	8f 10       	swpb	r15		
    a3c6:	0a 4f       	mov	r15,	r10	
    a3c8:	0a de       	bis	r14,	r10	
    a3ca:	5e 41 07 00 	mov.b	7(r1),	r14	;0x0007(r1)
    a3ce:	5f 41 08 00 	mov.b	8(r1),	r15	;0x0008(r1)
    a3d2:	8f 10       	swpb	r15		
    a3d4:	0b 4f       	mov	r15,	r11	
    a3d6:	0b de       	bis	r14,	r11	
    a3d8:	1e 42 04 02 	mov	&0x0204,r14	
    a3dc:	1f 42 06 02 	mov	&0x0206,r15	
    a3e0:	0b 9f       	cmp	r15,	r11	
    a3e2:	08 28       	jnc	$+18     	;abs 0xa3f4
    a3e4:	0f 9b       	cmp	r11,	r15	
    a3e6:	02 2c       	jc	$+6      	;abs 0xa3ec
    a3e8:	30 40 40 a6 	br	#0xa640	
    a3ec:	0a 9e       	cmp	r14,	r10	
    a3ee:	02 28       	jnc	$+6      	;abs 0xa3f4
    a3f0:	30 40 40 a6 	br	#0xa640	
    {
      uint8_t input_hash[SIZE_HASH];
      memcpy(input_hash, att_req_msg.hash, SIZE_HASH);
    a3f4:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a3f8:	0e 41       	mov	r1,	r14	
    a3fa:	3e 50 09 00 	add	#9,	r14	;#0x0009
    a3fe:	0f 41       	mov	r1,	r15	
    a400:	3f 50 2e 00 	add	#46,	r15	;#0x002e
    a404:	b0 12 58 b6 	call	#0xb658	
      for (int i = 0; i < cur_hash_idx - att_req_msg.hash_idx; i++)
    a408:	1e 42 04 02 	mov	&0x0204,r14	
    a40c:	1f 42 06 02 	mov	&0x0206,r15	
    a410:	0a 9e       	cmp	r14,	r10	
    a412:	02 20       	jnz	$+6      	;abs 0xa418
    a414:	0b 9f       	cmp	r15,	r11	
    a416:	2a 24       	jz	$+86     	;abs 0xa46c
    a418:	09 43       	clr	r9		
      {
        hash((uint8_t *)hash_res, (uint8_t *)input_hash, (uint32_t)SIZE_HASH);
    a41a:	3c 40 20 00 	mov	#32,	r12	;#0x0020
    a41e:	0d 43       	clr	r13		
    a420:	0e 41       	mov	r1,	r14	
    a422:	3e 50 2e 00 	add	#46,	r14	;#0x002e
    a426:	0f 41       	mov	r1,	r15	
    a428:	3f 50 4e 00 	add	#78,	r15	;#0x004e
    a42c:	b0 12 e8 b5 	call	#0xb5e8	
        memcpy(input_hash, hash_res, SIZE_HASH);
    a430:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a434:	0e 41       	mov	r1,	r14	
    a436:	3e 50 4e 00 	add	#78,	r14	;#0x004e
    a43a:	0f 41       	mov	r1,	r15	
    a43c:	3f 50 2e 00 	add	#46,	r15	;#0x002e
    a440:	b0 12 58 b6 	call	#0xb658	
    uint8_t hash_res[SIZE_HASH] = {0};
    if (cur_hash_idx > att_req_msg.hash_idx) // line 8
    {
      uint8_t input_hash[SIZE_HASH];
      memcpy(input_hash, att_req_msg.hash, SIZE_HASH);
      for (int i = 0; i < cur_hash_idx - att_req_msg.hash_idx; i++)
    a444:	19 53       	inc	r9		
    a446:	1c 42 04 02 	mov	&0x0204,r12	
    a44a:	1d 42 06 02 	mov	&0x0206,r13	
    a44e:	0f 49       	mov	r9,	r15	
    a450:	8f 10       	swpb	r15		
    a452:	8f 11       	sxt	r15		
    a454:	8f 10       	swpb	r15		
    a456:	8f 11       	sxt	r15		
    a458:	08 4f       	mov	r15,	r8	
    a45a:	0e 4c       	mov	r12,	r14	
    a45c:	0f 4d       	mov	r13,	r15	
    a45e:	0e 8a       	sub	r10,	r14	
    a460:	0f 7b       	subc	r11,	r15	
    a462:	08 9f       	cmp	r15,	r8	
    a464:	da 2b       	jnc	$-74     	;abs 0xa41a
    a466:	02 20       	jnz	$+6      	;abs 0xa46c
    a468:	09 9e       	cmp	r14,	r9	
    a46a:	d7 2b       	jnc	$-80     	;abs 0xa41a
      {
        hash((uint8_t *)hash_res, (uint8_t *)input_hash, (uint32_t)SIZE_HASH);
        memcpy(input_hash, hash_res, SIZE_HASH);
      }
      if (secure_memcmp(hash_res, cur_hash, SIZE_HASH) != 0)
    a46c:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a470:	3e 40 08 02 	mov	#520,	r14	;#0x0208
    a474:	0f 41       	mov	r1,	r15	
    a476:	3f 50 4e 00 	add	#78,	r15	;#0x004e
    a47a:	b0 12 2e a1 	call	#0xa12e	
    a47e:	0f 93       	tst	r15		
    a480:	df 20       	jnz	$+448    	;abs 0xa640
    }
    else
    {
      return;
    }
    memset(hash_res, 0, sizeof(hash_res));
    a482:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a486:	0e 43       	clr	r14		
    a488:	0f 41       	mov	r1,	r15	
    a48a:	3f 50 4e 00 	add	#78,	r15	;#0x004e
    a48e:	b0 12 52 b7 	call	#0xb752	

    parent = att_req_msg.snd_id;
    a492:	5c 41 01 00 	mov.b	1(r1),	r12	;0x0001(r1)
    a496:	5d 41 02 00 	mov.b	2(r1),	r13	;0x0002(r1)
    a49a:	8d 10       	swpb	r13		
    a49c:	0e 4d       	mov	r13,	r14	
    a49e:	0e dc       	bis	r12,	r14	
    a4a0:	5c 41 03 00 	mov.b	3(r1),	r12	;0x0003(r1)
    a4a4:	5d 41 04 00 	mov.b	4(r1),	r13	;0x0004(r1)
    a4a8:	8d 10       	swpb	r13		
    a4aa:	0f 4d       	mov	r13,	r15	
    a4ac:	0f dc       	bis	r12,	r15	
    a4ae:	82 4e 2c 12 	mov	r14,	&0x122c	
    a4b2:	82 4f 2e 12 	mov	r15,	&0x122e	
    cur_hash_idx = att_req_msg.hash_idx;
    a4b6:	82 4a 04 02 	mov	r10,	&0x0204	
    a4ba:	82 4b 06 02 	mov	r11,	&0x0206	
   // send_buf(&cur_hash, SIZE_HASH);
   // send_buf(&att_req_msg.hash, SIZE_HASH);
    memcpy(cur_hash, att_req_msg.hash, SIZE_HASH);
    a4be:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a4c2:	0e 41       	mov	r1,	r14	
    a4c4:	3e 50 09 00 	add	#9,	r14	;#0x0009
    a4c8:	3f 40 08 02 	mov	#520,	r15	;#0x0208
    a4cc:	b0 12 58 b6 	call	#0xb658	
  //  send_buf(&cur_hash, SIZE_HASH);
    att_req_msg.snd_id = dev_id;
    a4d0:	1e 42 00 02 	mov	&0x0200,r14	
    a4d4:	1f 42 02 02 	mov	&0x0202,r15	
    a4d8:	c1 4e 01 00 	mov.b	r14,	1(r1)	;0x0001(r1)
    a4dc:	8e 10       	swpb	r14		
    a4de:	c1 4e 02 00 	mov.b	r14,	2(r1)	;0x0002(r1)
    a4e2:	c1 4f 03 00 	mov.b	r15,	3(r1)	;0x0003(r1)
    a4e6:	8f 10       	swpb	r15		
    a4e8:	c1 4f 04 00 	mov.b	r15,	4(r1)	;0x0004(r1)
    att_req_msg.msg_type = MSG_TYPE_REP;
    a4ec:	e1 43 00 00 	mov.b	#2,	0(r1)	;r3 As==10, 0x0000(r1)
   // send_buf(&sendI, sizeof(sendI));
   // send_buf(&sendI, sizeof(sendI));
   // send_buf(&att_req_msg, sizeof(att_req_msg));

    struct auth_rep auth_rep_struct;
    auth_rep_struct.dev_id = parent;
    a4f0:	1a 42 2c 12 	mov	&0x122c,r10	
    a4f4:	1b 42 2e 12 	mov	&0x122e,r11	
    auth_rep_struct.cur_time = att_req_msg.cur_time;
    a4f8:	58 41 29 00 	mov.b	41(r1),	r8	;0x0029(r1)
    a4fc:	5f 41 2a 00 	mov.b	42(r1),	r15	;0x002a(r1)
    a500:	8f 10       	swpb	r15		
    a502:	08 df       	bis	r15,	r8	
    a504:	59 41 2b 00 	mov.b	43(r1),	r9	;0x002b(r1)
    a508:	5f 41 2c 00 	mov.b	44(r1),	r15	;0x002c(r1)
    a50c:	8f 10       	swpb	r15		
    a50e:	09 df       	bis	r15,	r9	
    memcpy(auth_rep_struct.new_hash, att_req_msg.hash, SIZE_HASH);
    a510:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    a514:	0e 41       	mov	r1,	r14	
    a516:	3e 50 09 00 	add	#9,	r14	;#0x0009
    a51a:	0f 41       	mov	r1,	r15	
    a51c:	3f 50 76 00 	add	#118,	r15	;#0x0076
    a520:	b0 12 58 b6 	call	#0xb658	

    uintptr_t memory_address = (uintptr_t)0x5800;
    struct auth_rep *ptr = (struct auth_rep *)memory_address;
    *ptr = auth_rep_struct;
    a524:	3d 40 28 00 	mov	#40,	r13	;#0x0028
    a528:	0e 41       	mov	r1,	r14	
    a52a:	3e 50 6e 00 	add	#110,	r14	;#0x006e
    a52e:	3f 40 00 58 	mov	#22528,	r15	;#0x5800
    a532:	b0 12 58 b6 	call	#0xb658	
    a536:	c2 4a 00 58 	mov.b	r10,	&0x5800	
    a53a:	0f 4a       	mov	r10,	r15	
    a53c:	8f 10       	swpb	r15		
    a53e:	c2 4f 01 58 	mov.b	r15,	&0x5801	
    a542:	c2 4b 02 58 	mov.b	r11,	&0x5802	
    a546:	0f 4b       	mov	r11,	r15	
    a548:	8f 10       	swpb	r15		
    a54a:	c2 4f 03 58 	mov.b	r15,	&0x5803	
    a54e:	c2 48 04 58 	mov.b	r8,	&0x5804	
    a552:	88 10       	swpb	r8		
    a554:	c2 48 05 58 	mov.b	r8,	&0x5805	
    a558:	c2 49 06 58 	mov.b	r9,	&0x5806	
    a55c:	89 10       	swpb	r9		
    a55e:	c2 49 07 58 	mov.b	r9,	&0x5807	

   
    //enable timer interrupt
    TACTL = TASSEL_2 + ID_3 + MC_1;
    a562:	b2 40 d0 02 	mov	#720,	&0x0160	;#0x02d0
    a566:	60 01 
    TACCR0 = TRAPS_TIME;
    a568:	b2 43 72 01 	mov	#-1,	&0x0172	;r3 As==11
    uint32_t timr = 0;
    uintptr_t timer_address = (uintptr_t)0x5768;
    uint32_t *timerptr = (uint32_t *)timer_address;
    *timerptr = timr;
    a56c:	82 43 68 57 	mov	#0,	&0x5768	;r3 As==00
    a570:	82 43 6a 57 	mov	#0,	&0x576a	;r3 As==00

    CCTL0 = CCIE; 
    a574:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    a578:	62 01 
    UART_CTL &= ~UART_IEN_RX;
    a57a:	3f 40 80 00 	mov	#128,	r15	;#0x0080
    a57e:	6e 4f       	mov.b	@r15,	r14	
    a580:	7e f0 ef ff 	and.b	#-17,	r14	;#0xffef
    a584:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    break;
    a588:	58 3c       	jmp	$+178    	;abs 0xa63a
  case MSG_TYPE_REP:;
    struct att_rep rep_msg;
    if (rx_start > rx_end)
    a58a:	58 42 28 12 	mov.b	&0x1228,r8	
    a58e:	48 9e       	cmp.b	r14,	r8	
    a590:	25 2c       	jc	$+76     	;abs 0xa5dc
    {
      my_memcpy((uint8_t *)&rep_msg, &rxdata[rx_start], RING_BUF_SIZE - rx_start); // line 4
    a592:	3a 40 00 01 	mov	#256,	r10	;#0x0100
    a596:	0a 8f       	sub	r15,	r10	
    a598:	4e 4e       	mov.b	r14,	r14	
    a59a:	09 4e       	mov	r14,	r9	
    a59c:	39 50 3c 12 	add	#4668,	r9	;#0x123c
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a5a0:	1a 93       	cmp	#1,	r10	;r3 As==01
    a5a2:	0c 38       	jl	$+26     	;abs 0xa5bc
    a5a4:	0f 43       	clr	r15		
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a5a6:	3d 40 96 00 	mov	#150,	r13	;#0x0096
    a5aa:	0d 51       	add	r1,	r13	
    a5ac:	0d 5f       	add	r15,	r13	
    a5ae:	0c 49       	mov	r9,	r12	
    a5b0:	0c 5f       	add	r15,	r12	
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    dst[i] = src[i];
    a5b2:	ed 4c 00 00 	mov.b	@r12,	0(r13)	;0x0000(r13)
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a5b6:	1f 53       	inc	r15		
    a5b8:	0f 9a       	cmp	r10,	r15	
    a5ba:	f5 23       	jnz	$-20     	;abs 0xa5a6
  case MSG_TYPE_REP:;
    struct att_rep rep_msg;
    if (rx_start > rx_end)
    {
      my_memcpy((uint8_t *)&rep_msg, &rxdata[rx_start], RING_BUF_SIZE - rx_start); // line 4
      my_memcpy(((uint8_t *)&rep_msg + RING_BUF_SIZE - rx_start), &rxdata[0], rx_end + 1);
    a5bc:	0c 41       	mov	r1,	r12	
    a5be:	0c 8e       	sub	r14,	r12	
    a5c0:	3c 50 96 01 	add	#406,	r12	;#0x0196
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a5c4:	4d 48       	mov.b	r8,	r13	
    a5c6:	1d 53       	inc	r13		
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a5c8:	0f 43       	clr	r15		
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a5ca:	0e 4c       	mov	r12,	r14	
    a5cc:	0e 5f       	add	r15,	r14	
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    dst[i] = src[i];
    a5ce:	de 4f 3c 12 	mov.b	4668(r15),0(r14)	;0x123c(r15), 0x0000(r14)
    a5d2:	00 00 
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a5d4:	1f 53       	inc	r15		
    a5d6:	0f 9d       	cmp	r13,	r15	
    a5d8:	f8 23       	jnz	$-14     	;abs 0xa5ca
    a5da:	16 3c       	jmp	$+46     	;abs 0xa608
      my_memcpy((uint8_t *)&rep_msg, &rxdata[rx_start], RING_BUF_SIZE - rx_start); // line 4
      my_memcpy(((uint8_t *)&rep_msg + RING_BUF_SIZE - rx_start), &rxdata[0], rx_end + 1);
    }
    else
    {
      my_memcpy((uint8_t *)&rep_msg, &rxdata[rx_start], rx_end - rx_start + 1);
    a5dc:	4a 48       	mov.b	r8,	r10	
    a5de:	0a 8f       	sub	r15,	r10	
    a5e0:	4e 4e       	mov.b	r14,	r14	
    a5e2:	3e 50 3c 12 	add	#4668,	r14	;#0x123c
    a5e6:	0f 4a       	mov	r10,	r15	
    a5e8:	1f 53       	inc	r15		
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a5ea:	1f 93       	cmp	#1,	r15	;r3 As==01
    a5ec:	0d 38       	jl	$+28     	;abs 0xa608
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a5ee:	0a 4f       	mov	r15,	r10	
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a5f0:	0f 43       	clr	r15		
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
                   "\n\t");
}

__attribute__((section(".do_mac.lib"))) void read_byte()
    a5f2:	3d 40 96 00 	mov	#150,	r13	;#0x0096
    a5f6:	0d 51       	add	r1,	r13	
    a5f8:	0d 5f       	add	r15,	r13	
    a5fa:	0c 4e       	mov	r14,	r12	
    a5fc:	0c 5f       	add	r15,	r12	
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    dst[i] = src[i];
    a5fe:	ed 4c 00 00 	mov.b	@r12,	0(r13)	;0x0000(r13)
    uint8_t *data,
    uint32_t datalen);

__attribute__((section(".do_mac.lib"))) inline void my_memcpy(uint8_t *dst, uint8_t *src, int size)
{
  for (int i = 0; i < size; i++)
    a602:	1f 53       	inc	r15		
    a604:	0f 9a       	cmp	r10,	r15	
    a606:	f5 23       	jnz	$-20     	;abs 0xa5f2
    }
    else
    {
      my_memcpy((uint8_t *)&rep_msg, &rxdata[rx_start], rx_end - rx_start + 1);
    }
    send_buf((uint8_t *)&rep_msg, sizeof(rep_msg));
    a608:	3e 40 4d 00 	mov	#77,	r14	;#0x004d
    a60c:	0f 41       	mov	r1,	r15	
    a60e:	3f 50 96 00 	add	#150,	r15	;#0x0096
    a612:	b0 12 92 a2 	call	#0xa292	
    memset(rxdata, 0, sizeof(rxdata));
    a616:	3d 40 00 01 	mov	#256,	r13	;#0x0100
    a61a:	0e 43       	clr	r14		
    a61c:	3f 40 3c 12 	mov	#4668,	r15	;#0x123c
    a620:	b0 12 52 b7 	call	#0xb752	
    rx_start = 0;
    a624:	c2 43 2a 12 	mov.b	#0,	&0x122a	;r3 As==00
    rx_end = 0;
    a628:	c2 43 28 12 	mov.b	#0,	&0x1228	;r3 As==00
    // if (rep_msg.attesttime == cur_time)
    // {
    //    rep_msg.par = parent;
       send_buf(&rep_msg, sizeof(rep_msg));
    a62c:	3e 40 4d 00 	mov	#77,	r14	;#0x004d
    a630:	0f 41       	mov	r1,	r15	
    a632:	3f 50 96 00 	add	#150,	r15	;#0x0096
    a636:	b0 12 92 a2 	call	#0xa292	
    // }
    break;
  default:
    break;
  }
  UART_STAT = UART_RX_PND;
    a63a:	f2 40 10 00 	mov.b	#16,	&0x0081	;#0x0010
    a63e:	81 00 
}
    a640:	31 50 e4 00 	add	#228,	r1	;#0x00e4
    a644:	37 41       	pop	r7		
    a646:	38 41       	pop	r8		
    a648:	39 41       	pop	r9		
    a64a:	3a 41       	pop	r10		
    a64c:	3b 41       	pop	r11		
    a64e:	30 41       	ret			

0000a650 <time_sync>:
  uint8_t auth_rep[SIZE_HASH];
};

/* time sync function */
__attribute__((section(".do_mac.lib"))) void time_sync()
{
    a650:	21 83       	decd	r1		
  uint8_t readyByte = 0;
    a652:	c1 43 00 00 	mov.b	#0,	0(r1)	;r3 As==00, 0x0000(r1)
  uint8_t sendByte = ACKTWO;
    a656:	f1 40 66 00 	mov.b	#102,	1(r1)	;#0x0066, 0x0001(r1)
    a65a:	01 00 
  send_buf(&sendByte, sizeof(sendByte));
    a65c:	1e 43       	mov	#1,	r14	;r3 As==01
    a65e:	0f 41       	mov	r1,	r15	
    a660:	1f 53       	inc	r15		
    a662:	b0 12 92 a2 	call	#0xa292	
  while (readyByte != ACK)
    a666:	f1 90 61 00 	cmp.b	#97,	0(r1)	;#0x0061, 0x0000(r1)
    a66a:	00 00 
    a66c:	0d 24       	jz	$+28     	;abs 0xa688
  {

    send_buf(&sendByte, sizeof(sendByte));
    a66e:	1e 43       	mov	#1,	r14	;r3 As==01
    a670:	0f 41       	mov	r1,	r15	
    a672:	1f 53       	inc	r15		
    a674:	b0 12 92 a2 	call	#0xa292	
    recv_buf(&readyByte, sizeof(readyByte));
    a678:	1e 43       	mov	#1,	r14	;r3 As==01
    a67a:	0f 41       	mov	r1,	r15	
    a67c:	b0 12 04 a2 	call	#0xa204	
__attribute__((section(".do_mac.lib"))) void time_sync()
{
  uint8_t readyByte = 0;
  uint8_t sendByte = ACKTWO;
  send_buf(&sendByte, sizeof(sendByte));
  while (readyByte != ACK)
    a680:	f1 90 61 00 	cmp.b	#97,	0(r1)	;#0x0061, 0x0000(r1)
    a684:	00 00 
    a686:	f3 23       	jnz	$-24     	;abs 0xa66e

    send_buf(&sendByte, sizeof(sendByte));
    recv_buf(&readyByte, sizeof(readyByte));
  }

  recv_buf(&epoch_time, sizeof(epoch_time));
    a688:	2e 42       	mov	#4,	r14	;r2 As==10
    a68a:	3f 40 3c 13 	mov	#4924,	r15	;#0x133c
    a68e:	b0 12 04 a2 	call	#0xa204	
  send_buf(&epoch_time, sizeof(epoch_time));
    a692:	2e 42       	mov	#4,	r14	;r2 As==10
    a694:	3f 40 3c 13 	mov	#4924,	r15	;#0x133c
    a698:	b0 12 92 a2 	call	#0xa292	

  return;
}
    a69c:	21 53       	incd	r1		
    a69e:	30 41       	ret			

0000a6a0 <Hacl_Impl_SHA2_256_init>:
  uint32_t *p4 = k1 + (uint32_t)48U;
  uint32_t *p11 = p10;
  uint32_t *p21 = p10 + (uint32_t)8U;
  uint32_t *p12 = p11;
  uint32_t *p22 = p11 + (uint32_t)4U;
  p12[0U] = (uint32_t)0x428a2f98U;
    a6a0:	bf 40 98 2f 	mov	#12184,	0(r15)	;#0x2f98, 0x0000(r15)
    a6a4:	00 00 
    a6a6:	bf 40 8a 42 	mov	#17034,	2(r15)	;#0x428a, 0x0002(r15)
    a6aa:	02 00 
  p12[1U] = (uint32_t)0x71374491U;
    a6ac:	bf 40 91 44 	mov	#17553,	4(r15)	;#0x4491, 0x0004(r15)
    a6b0:	04 00 
    a6b2:	bf 40 37 71 	mov	#28983,	6(r15)	;#0x7137, 0x0006(r15)
    a6b6:	06 00 
  p12[2U] = (uint32_t)0xb5c0fbcfU;
    a6b8:	bf 40 cf fb 	mov	#-1073,	8(r15)	;#0xfbcf, 0x0008(r15)
    a6bc:	08 00 
    a6be:	bf 40 c0 b5 	mov	#-19008,10(r15)	;#0xb5c0, 0x000a(r15)
    a6c2:	0a 00 
  p12[3U] = (uint32_t)0xe9b5dba5U;
    a6c4:	bf 40 a5 db 	mov	#-9307,	12(r15)	;#0xdba5, 0x000c(r15)
    a6c8:	0c 00 
    a6ca:	bf 40 b5 e9 	mov	#-5707,	14(r15)	;#0xe9b5, 0x000e(r15)
    a6ce:	0e 00 
  p22[0U] = (uint32_t)0x3956c25bU;
    a6d0:	bf 40 5b c2 	mov	#-15781,16(r15)	;#0xc25b, 0x0010(r15)
    a6d4:	10 00 
    a6d6:	bf 40 56 39 	mov	#14678,	18(r15)	;#0x3956, 0x0012(r15)
    a6da:	12 00 
  p22[1U] = (uint32_t)0x59f111f1U;
    a6dc:	bf 40 f1 11 	mov	#4593,	20(r15)	;#0x11f1, 0x0014(r15)
    a6e0:	14 00 
    a6e2:	bf 40 f1 59 	mov	#23025,	22(r15)	;#0x59f1, 0x0016(r15)
    a6e6:	16 00 
  p22[2U] = (uint32_t)0x923f82a4U;
    a6e8:	bf 40 a4 82 	mov	#-32092,24(r15)	;#0x82a4, 0x0018(r15)
    a6ec:	18 00 
    a6ee:	bf 40 3f 92 	mov	#-28097,26(r15)	;#0x923f, 0x001a(r15)
    a6f2:	1a 00 
  p22[3U] = (uint32_t)0xab1c5ed5U;
    a6f4:	bf 40 d5 5e 	mov	#24277,	28(r15)	;#0x5ed5, 0x001c(r15)
    a6f8:	1c 00 
    a6fa:	bf 40 1c ab 	mov	#-21732,30(r15)	;#0xab1c, 0x001e(r15)
    a6fe:	1e 00 
  uint32_t *p13 = p21;
  uint32_t *p23 = p21 + (uint32_t)4U;
  p13[0U] = (uint32_t)0xd807aa98U;
    a700:	bf 40 98 aa 	mov	#-21864,32(r15)	;#0xaa98, 0x0020(r15)
    a704:	20 00 
    a706:	bf 40 07 d8 	mov	#-10233,34(r15)	;#0xd807, 0x0022(r15)
    a70a:	22 00 
  p13[1U] = (uint32_t)0x12835b01U;
    a70c:	bf 40 01 5b 	mov	#23297,	36(r15)	;#0x5b01, 0x0024(r15)
    a710:	24 00 
    a712:	bf 40 83 12 	mov	#4739,	38(r15)	;#0x1283, 0x0026(r15)
    a716:	26 00 
  p13[2U] = (uint32_t)0x243185beU;
    a718:	bf 40 be 85 	mov	#-31298,40(r15)	;#0x85be, 0x0028(r15)
    a71c:	28 00 
    a71e:	bf 40 31 24 	mov	#9265,	42(r15)	;#0x2431, 0x002a(r15)
    a722:	2a 00 
  p13[3U] = (uint32_t)0x550c7dc3U;
    a724:	bf 40 c3 7d 	mov	#32195,	44(r15)	;#0x7dc3, 0x002c(r15)
    a728:	2c 00 
    a72a:	bf 40 0c 55 	mov	#21772,	46(r15)	;#0x550c, 0x002e(r15)
    a72e:	2e 00 
  p23[0U] = (uint32_t)0x72be5d74U;
    a730:	bf 40 74 5d 	mov	#23924,	48(r15)	;#0x5d74, 0x0030(r15)
    a734:	30 00 
    a736:	bf 40 be 72 	mov	#29374,	50(r15)	;#0x72be, 0x0032(r15)
    a73a:	32 00 
  p23[1U] = (uint32_t)0x80deb1feU;
    a73c:	bf 40 fe b1 	mov	#-19970,52(r15)	;#0xb1fe, 0x0034(r15)
    a740:	34 00 
    a742:	bf 40 de 80 	mov	#-32546,54(r15)	;#0x80de, 0x0036(r15)
    a746:	36 00 
  p23[2U] = (uint32_t)0x9bdc06a7U;
    a748:	bf 40 a7 06 	mov	#1703,	56(r15)	;#0x06a7, 0x0038(r15)
    a74c:	38 00 
    a74e:	bf 40 dc 9b 	mov	#-25636,58(r15)	;#0x9bdc, 0x003a(r15)
    a752:	3a 00 
  p23[3U] = (uint32_t)0xc19bf174U;
    a754:	bf 40 74 f1 	mov	#-3724,	60(r15)	;#0xf174, 0x003c(r15)
    a758:	3c 00 
    a75a:	bf 40 9b c1 	mov	#-15973,62(r15)	;#0xc19b, 0x003e(r15)
    a75e:	3e 00 
  uint32_t *p14 = p20;
  uint32_t *p24 = p20 + (uint32_t)8U;
  uint32_t *p15 = p14;
  uint32_t *p25 = p14 + (uint32_t)4U;
  p15[0U] = (uint32_t)0xe49b69c1U;
    a760:	bf 40 c1 69 	mov	#27073,	64(r15)	;#0x69c1, 0x0040(r15)
    a764:	40 00 
    a766:	bf 40 9b e4 	mov	#-7013,	66(r15)	;#0xe49b, 0x0042(r15)
    a76a:	42 00 
  p15[1U] = (uint32_t)0xefbe4786U;
    a76c:	bf 40 86 47 	mov	#18310,	68(r15)	;#0x4786, 0x0044(r15)
    a770:	44 00 
    a772:	bf 40 be ef 	mov	#-4162,	70(r15)	;#0xefbe, 0x0046(r15)
    a776:	46 00 
  p15[2U] = (uint32_t)0x0fc19dc6U;
    a778:	bf 40 c6 9d 	mov	#-25146,72(r15)	;#0x9dc6, 0x0048(r15)
    a77c:	48 00 
    a77e:	bf 40 c1 0f 	mov	#4033,	74(r15)	;#0x0fc1, 0x004a(r15)
    a782:	4a 00 
  p15[3U] = (uint32_t)0x240ca1ccU;
    a784:	bf 40 cc a1 	mov	#-24116,76(r15)	;#0xa1cc, 0x004c(r15)
    a788:	4c 00 
    a78a:	bf 40 0c 24 	mov	#9228,	78(r15)	;#0x240c, 0x004e(r15)
    a78e:	4e 00 
  p25[0U] = (uint32_t)0x2de92c6fU;
    a790:	bf 40 6f 2c 	mov	#11375,	80(r15)	;#0x2c6f, 0x0050(r15)
    a794:	50 00 
    a796:	bf 40 e9 2d 	mov	#11753,	82(r15)	;#0x2de9, 0x0052(r15)
    a79a:	52 00 
  p25[1U] = (uint32_t)0x4a7484aaU;
    a79c:	bf 40 aa 84 	mov	#-31574,84(r15)	;#0x84aa, 0x0054(r15)
    a7a0:	54 00 
    a7a2:	bf 40 74 4a 	mov	#19060,	86(r15)	;#0x4a74, 0x0056(r15)
    a7a6:	56 00 
  p25[2U] = (uint32_t)0x5cb0a9dcU;
    a7a8:	bf 40 dc a9 	mov	#-22052,88(r15)	;#0xa9dc, 0x0058(r15)
    a7ac:	58 00 
    a7ae:	bf 40 b0 5c 	mov	#23728,	90(r15)	;#0x5cb0, 0x005a(r15)
    a7b2:	5a 00 
  p25[3U] = (uint32_t)0x76f988daU;
    a7b4:	bf 40 da 88 	mov	#-30502,92(r15)	;#0x88da, 0x005c(r15)
    a7b8:	5c 00 
    a7ba:	bf 40 f9 76 	mov	#30457,	94(r15)	;#0x76f9, 0x005e(r15)
    a7be:	5e 00 
  uint32_t *p16 = p24;
  uint32_t *p26 = p24 + (uint32_t)4U;
  p16[0U] = (uint32_t)0x983e5152U;
    a7c0:	bf 40 52 51 	mov	#20818,	96(r15)	;#0x5152, 0x0060(r15)
    a7c4:	60 00 
    a7c6:	bf 40 3e 98 	mov	#-26562,98(r15)	;#0x983e, 0x0062(r15)
    a7ca:	62 00 
  p16[1U] = (uint32_t)0xa831c66dU;
    a7cc:	bf 40 6d c6 	mov	#-14739,100(r15);#0xc66d, 0x0064(r15)
    a7d0:	64 00 
    a7d2:	bf 40 31 a8 	mov	#-22479,102(r15);#0xa831, 0x0066(r15)
    a7d6:	66 00 
  p16[2U] = (uint32_t)0xb00327c8U;
    a7d8:	bf 40 c8 27 	mov	#10184,	104(r15);#0x27c8, 0x0068(r15)
    a7dc:	68 00 
    a7de:	bf 40 03 b0 	mov	#-20477,106(r15);#0xb003, 0x006a(r15)
    a7e2:	6a 00 
  p16[3U] = (uint32_t)0xbf597fc7U;
    a7e4:	bf 40 c7 7f 	mov	#32711,	108(r15);#0x7fc7, 0x006c(r15)
    a7e8:	6c 00 
    a7ea:	bf 40 59 bf 	mov	#-16551,110(r15);#0xbf59, 0x006e(r15)
    a7ee:	6e 00 
  p26[0U] = (uint32_t)0xc6e00bf3U;
    a7f0:	bf 40 f3 0b 	mov	#3059,	112(r15);#0x0bf3, 0x0070(r15)
    a7f4:	70 00 
    a7f6:	bf 40 e0 c6 	mov	#-14624,114(r15);#0xc6e0, 0x0072(r15)
    a7fa:	72 00 
  p26[1U] = (uint32_t)0xd5a79147U;
    a7fc:	bf 40 47 91 	mov	#-28345,116(r15);#0x9147, 0x0074(r15)
    a800:	74 00 
    a802:	bf 40 a7 d5 	mov	#-10841,118(r15);#0xd5a7, 0x0076(r15)
    a806:	76 00 
  p26[2U] = (uint32_t)0x06ca6351U;
    a808:	bf 40 51 63 	mov	#25425,	120(r15);#0x6351, 0x0078(r15)
    a80c:	78 00 
    a80e:	bf 40 ca 06 	mov	#1738,	122(r15);#0x06ca, 0x007a(r15)
    a812:	7a 00 
  p26[3U] = (uint32_t)0x14292967U;
    a814:	bf 40 67 29 	mov	#10599,	124(r15);#0x2967, 0x007c(r15)
    a818:	7c 00 
    a81a:	bf 40 29 14 	mov	#5161,	126(r15);#0x1429, 0x007e(r15)
    a81e:	7e 00 
  uint32_t *p17 = p3;
  uint32_t *p27 = p3 + (uint32_t)8U;
  uint32_t *p18 = p17;
  uint32_t *p28 = p17 + (uint32_t)4U;
  p18[0U] = (uint32_t)0x27b70a85U;
    a820:	bf 40 85 0a 	mov	#2693,	128(r15);#0x0a85, 0x0080(r15)
    a824:	80 00 
    a826:	bf 40 b7 27 	mov	#10167,	130(r15);#0x27b7, 0x0082(r15)
    a82a:	82 00 
  p18[1U] = (uint32_t)0x2e1b2138U;
    a82c:	bf 40 38 21 	mov	#8504,	132(r15);#0x2138, 0x0084(r15)
    a830:	84 00 
    a832:	bf 40 1b 2e 	mov	#11803,	134(r15);#0x2e1b, 0x0086(r15)
    a836:	86 00 
  p18[2U] = (uint32_t)0x4d2c6dfcU;
    a838:	bf 40 fc 6d 	mov	#28156,	136(r15);#0x6dfc, 0x0088(r15)
    a83c:	88 00 
    a83e:	bf 40 2c 4d 	mov	#19756,	138(r15);#0x4d2c, 0x008a(r15)
    a842:	8a 00 
  p18[3U] = (uint32_t)0x53380d13U;
    a844:	bf 40 13 0d 	mov	#3347,	140(r15);#0x0d13, 0x008c(r15)
    a848:	8c 00 
    a84a:	bf 40 38 53 	mov	#21304,	142(r15);#0x5338, 0x008e(r15)
    a84e:	8e 00 
  p28[0U] = (uint32_t)0x650a7354U;
    a850:	bf 40 54 73 	mov	#29524,	144(r15);#0x7354, 0x0090(r15)
    a854:	90 00 
    a856:	bf 40 0a 65 	mov	#25866,	146(r15);#0x650a, 0x0092(r15)
    a85a:	92 00 
  p28[1U] = (uint32_t)0x766a0abbU;
    a85c:	bf 40 bb 0a 	mov	#2747,	148(r15);#0x0abb, 0x0094(r15)
    a860:	94 00 
    a862:	bf 40 6a 76 	mov	#30314,	150(r15);#0x766a, 0x0096(r15)
    a866:	96 00 
  p28[2U] = (uint32_t)0x81c2c92eU;
    a868:	bf 40 2e c9 	mov	#-14034,152(r15);#0xc92e, 0x0098(r15)
    a86c:	98 00 
    a86e:	bf 40 c2 81 	mov	#-32318,154(r15);#0x81c2, 0x009a(r15)
    a872:	9a 00 
  p28[3U] = (uint32_t)0x92722c85U;
    a874:	bf 40 85 2c 	mov	#11397,	156(r15);#0x2c85, 0x009c(r15)
    a878:	9c 00 
    a87a:	bf 40 72 92 	mov	#-28046,158(r15);#0x9272, 0x009e(r15)
    a87e:	9e 00 
  uint32_t *p19 = p27;
  uint32_t *p29 = p27 + (uint32_t)4U;
  p19[0U] = (uint32_t)0xa2bfe8a1U;
    a880:	bf 40 a1 e8 	mov	#-5983,	160(r15);#0xe8a1, 0x00a0(r15)
    a884:	a0 00 
    a886:	bf 40 bf a2 	mov	#-23873,162(r15);#0xa2bf, 0x00a2(r15)
    a88a:	a2 00 
  p19[1U] = (uint32_t)0xa81a664bU;
    a88c:	bf 40 4b 66 	mov	#26187,	164(r15);#0x664b, 0x00a4(r15)
    a890:	a4 00 
    a892:	bf 40 1a a8 	mov	#-22502,166(r15);#0xa81a, 0x00a6(r15)
    a896:	a6 00 
  p19[2U] = (uint32_t)0xc24b8b70U;
    a898:	bf 40 70 8b 	mov	#-29840,168(r15);#0x8b70, 0x00a8(r15)
    a89c:	a8 00 
    a89e:	bf 40 4b c2 	mov	#-15797,170(r15);#0xc24b, 0x00aa(r15)
    a8a2:	aa 00 
  p19[3U] = (uint32_t)0xc76c51a3U;
    a8a4:	bf 40 a3 51 	mov	#20899,	172(r15);#0x51a3, 0x00ac(r15)
    a8a8:	ac 00 
    a8aa:	bf 40 6c c7 	mov	#-14484,174(r15);#0xc76c, 0x00ae(r15)
    a8ae:	ae 00 
  p29[0U] = (uint32_t)0xd192e819U;
    a8b0:	bf 40 19 e8 	mov	#-6119,	176(r15);#0xe819, 0x00b0(r15)
    a8b4:	b0 00 
    a8b6:	bf 40 92 d1 	mov	#-11886,178(r15);#0xd192, 0x00b2(r15)
    a8ba:	b2 00 
  p29[1U] = (uint32_t)0xd6990624U;
    a8bc:	bf 40 24 06 	mov	#1572,	180(r15);#0x0624, 0x00b4(r15)
    a8c0:	b4 00 
    a8c2:	bf 40 99 d6 	mov	#-10599,182(r15);#0xd699, 0x00b6(r15)
    a8c6:	b6 00 
  p29[2U] = (uint32_t)0xf40e3585U;
    a8c8:	bf 40 85 35 	mov	#13701,	184(r15);#0x3585, 0x00b8(r15)
    a8cc:	b8 00 
    a8ce:	bf 40 0e f4 	mov	#-3058,	186(r15);#0xf40e, 0x00ba(r15)
    a8d2:	ba 00 
  p29[3U] = (uint32_t)0x106aa070U;
    a8d4:	bf 40 70 a0 	mov	#-24464,188(r15);#0xa070, 0x00bc(r15)
    a8d8:	bc 00 
    a8da:	bf 40 6a 10 	mov	#4202,	190(r15);#0x106a, 0x00be(r15)
    a8de:	be 00 
  uint32_t *p110 = p4;
  uint32_t *p210 = p4 + (uint32_t)8U;
  uint32_t *p1 = p110;
  uint32_t *p211 = p110 + (uint32_t)4U;
  p1[0U] = (uint32_t)0x19a4c116U;
    a8e0:	bf 40 16 c1 	mov	#-16106,192(r15);#0xc116, 0x00c0(r15)
    a8e4:	c0 00 
    a8e6:	bf 40 a4 19 	mov	#6564,	194(r15);#0x19a4, 0x00c2(r15)
    a8ea:	c2 00 
  p1[1U] = (uint32_t)0x1e376c08U;
    a8ec:	bf 40 08 6c 	mov	#27656,	196(r15);#0x6c08, 0x00c4(r15)
    a8f0:	c4 00 
    a8f2:	bf 40 37 1e 	mov	#7735,	198(r15);#0x1e37, 0x00c6(r15)
    a8f6:	c6 00 
  p1[2U] = (uint32_t)0x2748774cU;
    a8f8:	bf 40 4c 77 	mov	#30540,	200(r15);#0x774c, 0x00c8(r15)
    a8fc:	c8 00 
    a8fe:	bf 40 48 27 	mov	#10056,	202(r15);#0x2748, 0x00ca(r15)
    a902:	ca 00 
  p1[3U] = (uint32_t)0x34b0bcb5U;
    a904:	bf 40 b5 bc 	mov	#-17227,204(r15);#0xbcb5, 0x00cc(r15)
    a908:	cc 00 
    a90a:	bf 40 b0 34 	mov	#13488,	206(r15);#0x34b0, 0x00ce(r15)
    a90e:	ce 00 
  p211[0U] = (uint32_t)0x391c0cb3U;
    a910:	bf 40 b3 0c 	mov	#3251,	208(r15);#0x0cb3, 0x00d0(r15)
    a914:	d0 00 
    a916:	bf 40 1c 39 	mov	#14620,	210(r15);#0x391c, 0x00d2(r15)
    a91a:	d2 00 
  p211[1U] = (uint32_t)0x4ed8aa4aU;
    a91c:	bf 40 4a aa 	mov	#-21942,212(r15);#0xaa4a, 0x00d4(r15)
    a920:	d4 00 
    a922:	bf 40 d8 4e 	mov	#20184,	214(r15);#0x4ed8, 0x00d6(r15)
    a926:	d6 00 
  p211[2U] = (uint32_t)0x5b9cca4fU;
    a928:	bf 40 4f ca 	mov	#-13745,216(r15);#0xca4f, 0x00d8(r15)
    a92c:	d8 00 
    a92e:	bf 40 9c 5b 	mov	#23452,	218(r15);#0x5b9c, 0x00da(r15)
    a932:	da 00 
  p211[3U] = (uint32_t)0x682e6ff3U;
    a934:	bf 40 f3 6f 	mov	#28659,	220(r15);#0x6ff3, 0x00dc(r15)
    a938:	dc 00 
    a93a:	bf 40 2e 68 	mov	#26670,	222(r15);#0x682e, 0x00de(r15)
    a93e:	de 00 
  uint32_t *p111 = p210;
  uint32_t *p212 = p210 + (uint32_t)4U;
  p111[0U] = (uint32_t)0x748f82eeU;
    a940:	bf 40 ee 82 	mov	#-32018,224(r15);#0x82ee, 0x00e0(r15)
    a944:	e0 00 
    a946:	bf 40 8f 74 	mov	#29839,	226(r15);#0x748f, 0x00e2(r15)
    a94a:	e2 00 
  p111[1U] = (uint32_t)0x78a5636fU;
    a94c:	bf 40 6f 63 	mov	#25455,	228(r15);#0x636f, 0x00e4(r15)
    a950:	e4 00 
    a952:	bf 40 a5 78 	mov	#30885,	230(r15);#0x78a5, 0x00e6(r15)
    a956:	e6 00 
  p111[2U] = (uint32_t)0x84c87814U;
    a958:	bf 40 14 78 	mov	#30740,	232(r15);#0x7814, 0x00e8(r15)
    a95c:	e8 00 
    a95e:	bf 40 c8 84 	mov	#-31544,234(r15);#0x84c8, 0x00ea(r15)
    a962:	ea 00 
  p111[3U] = (uint32_t)0x8cc70208U;
    a964:	bf 40 08 02 	mov	#520,	236(r15);#0x0208, 0x00ec(r15)
    a968:	ec 00 
    a96a:	bf 40 c7 8c 	mov	#-29497,238(r15);#0x8cc7, 0x00ee(r15)
    a96e:	ee 00 
  p212[0U] = (uint32_t)0x90befffaU;
    a970:	bf 40 fa ff 	mov	#-6,	240(r15);#0xfffa, 0x00f0(r15)
    a974:	f0 00 
    a976:	bf 40 be 90 	mov	#-28482,242(r15);#0x90be, 0x00f2(r15)
    a97a:	f2 00 
  p212[1U] = (uint32_t)0xa4506cebU;
    a97c:	bf 40 eb 6c 	mov	#27883,	244(r15);#0x6ceb, 0x00f4(r15)
    a980:	f4 00 
    a982:	bf 40 50 a4 	mov	#-23472,246(r15);#0xa450, 0x00f6(r15)
    a986:	f6 00 
  p212[2U] = (uint32_t)0xbef9a3f7U;
    a988:	bf 40 f7 a3 	mov	#-23561,248(r15);#0xa3f7, 0x00f8(r15)
    a98c:	f8 00 
    a98e:	bf 40 f9 be 	mov	#-16647,250(r15);#0xbef9, 0x00fa(r15)
    a992:	fa 00 
  p212[3U] = (uint32_t)0xc67178f2U;
    a994:	bf 40 f2 78 	mov	#30962,	252(r15);#0x78f2, 0x00fc(r15)
    a998:	fc 00 
    a99a:	bf 40 71 c6 	mov	#-14735,254(r15);#0xc671, 0x00fe(r15)
    a99e:	fe 00 
  uint32_t *p112 = h_01;
  uint32_t *p2 = h_01 + (uint32_t)4U;
  p112[0U] = (uint32_t)0x6a09e667U;
    a9a0:	bf 40 67 e6 	mov	#-6553,	512(r15);#0xe667, 0x0200(r15)
    a9a4:	00 02 
    a9a6:	bf 40 09 6a 	mov	#27145,	514(r15);#0x6a09, 0x0202(r15)
    a9aa:	02 02 
  p112[1U] = (uint32_t)0xbb67ae85U;
    a9ac:	bf 40 85 ae 	mov	#-20859,516(r15);#0xae85, 0x0204(r15)
    a9b0:	04 02 
    a9b2:	bf 40 67 bb 	mov	#-17561,518(r15);#0xbb67, 0x0206(r15)
    a9b6:	06 02 
  p112[2U] = (uint32_t)0x3c6ef372U;
    a9b8:	bf 40 72 f3 	mov	#-3214,	520(r15);#0xf372, 0x0208(r15)
    a9bc:	08 02 
    a9be:	bf 40 6e 3c 	mov	#15470,	522(r15);#0x3c6e, 0x020a(r15)
    a9c2:	0a 02 
  p112[3U] = (uint32_t)0xa54ff53aU;
    a9c4:	bf 40 3a f5 	mov	#-2758,	524(r15);#0xf53a, 0x020c(r15)
    a9c8:	0c 02 
    a9ca:	bf 40 4f a5 	mov	#-23217,526(r15);#0xa54f, 0x020e(r15)
    a9ce:	0e 02 
  p2[0U] = (uint32_t)0x510e527fU;
    a9d0:	bf 40 7f 52 	mov	#21119,	528(r15);#0x527f, 0x0210(r15)
    a9d4:	10 02 
    a9d6:	bf 40 0e 51 	mov	#20750,	530(r15);#0x510e, 0x0212(r15)
    a9da:	12 02 
  p2[1U] = (uint32_t)0x9b05688cU;
    a9dc:	bf 40 8c 68 	mov	#26764,	532(r15);#0x688c, 0x0214(r15)
    a9e0:	14 02 
    a9e2:	bf 40 05 9b 	mov	#-25851,534(r15);#0x9b05, 0x0216(r15)
    a9e6:	16 02 
  p2[2U] = (uint32_t)0x1f83d9abU;
    a9e8:	bf 40 ab d9 	mov	#-9813,	536(r15);#0xd9ab, 0x0218(r15)
    a9ec:	18 02 
    a9ee:	bf 40 83 1f 	mov	#8067,	538(r15);#0x1f83, 0x021a(r15)
    a9f2:	1a 02 
  p2[3U] = (uint32_t)0x5be0cd19U;
    a9f4:	bf 40 19 cd 	mov	#-13031,540(r15);#0xcd19, 0x021c(r15)
    a9f8:	1c 02 
    a9fa:	bf 40 e0 5b 	mov	#23520,	542(r15);#0x5be0, 0x021e(r15)
    a9fe:	1e 02 
}
    aa00:	30 41       	ret			

0000aa02 <Hacl_Impl_HMAC_SHA2_256_xor_bytes_inplace>:
  Hacl_Impl_SHA2_256_update_last(state, input_last, r);
  Hacl_Impl_SHA2_256_finish(state, hash1);
}

static void Hacl_Impl_HMAC_SHA2_256_xor_bytes_inplace(uint8_t *a, uint8_t *b, uint32_t len)
{
    aa02:	0b 12       	push	r11		
    aa04:	0a 12       	push	r10		
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
    aa06:	0c 93       	tst	r12		
    aa08:	02 20       	jnz	$+6      	;abs 0xaa0e
    aa0a:	0d 93       	tst	r13		
    aa0c:	0b 24       	jz	$+24     	;abs 0xaa24
    aa0e:	0a 43       	clr	r10		
    aa10:	0b 43       	clr	r11		
  {
    uint8_t xi = a[i];
    uint8_t yi = b[i];
    a[i] = xi ^ yi;
    aa12:	ff ee 00 00 	xor.b	@r14+,	0(r15)	;0x0000(r15)
  Hacl_Impl_SHA2_256_finish(state, hash1);
}

static void Hacl_Impl_HMAC_SHA2_256_xor_bytes_inplace(uint8_t *a, uint8_t *b, uint32_t len)
{
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
    aa16:	1a 53       	inc	r10		
    aa18:	0b 63       	adc	r11		
    aa1a:	1f 53       	inc	r15		
    aa1c:	0a 9c       	cmp	r12,	r10	
    aa1e:	f9 23       	jnz	$-12     	;abs 0xaa12
    aa20:	0b 9d       	cmp	r13,	r11	
    aa22:	f7 23       	jnz	$-16     	;abs 0xaa12
  {
    uint8_t xi = a[i];
    uint8_t yi = b[i];
    a[i] = xi ^ yi;
  }
}
    aa24:	3a 41       	pop	r10		
    aa26:	3b 41       	pop	r11		
    aa28:	30 41       	ret			

0000aa2a <Hacl_Impl_SHA2_256_update>:
  p2[2U] = (uint32_t)0x1f83d9abU;
  p2[3U] = (uint32_t)0x5be0cd19U;
}

static void Hacl_Impl_SHA2_256_update(uint32_t *state, uint8_t *data)
{
    aa2a:	0b 12       	push	r11		
    aa2c:	0a 12       	push	r10		
    aa2e:	09 12       	push	r9		
    aa30:	08 12       	push	r8		
    aa32:	07 12       	push	r7		
    aa34:	06 12       	push	r6		
    aa36:	05 12       	push	r5		
    aa38:	04 12       	push	r4		
    aa3a:	31 50 64 ff 	add	#-156,	r1	;#0xff64
    aa3e:	81 4f 98 00 	mov	r15,	152(r1)	;0x0098(r1)
    aa42:	0a 4e       	mov	r14,	r10	
  uint32_t data_w[16U] = { 0U };
    aa44:	3d 40 40 00 	mov	#64,	r13	;#0x0040
    aa48:	0e 43       	clr	r14		
    aa4a:	0f 41       	mov	r1,	r15	
    aa4c:	b0 12 52 b7 	call	#0xb752	
  p2[1U] = (uint32_t)0x9b05688cU;
  p2[2U] = (uint32_t)0x1f83d9abU;
  p2[3U] = (uint32_t)0x5be0cd19U;
}

static void Hacl_Impl_SHA2_256_update(uint32_t *state, uint8_t *data)
    aa50:	04 41       	mov	r1,	r4	
    aa52:	34 50 40 00 	add	#64,	r4	;#0x0040
    aa56:	05 41       	mov	r1,	r5	
    aa58:	0e 4a       	mov	r10,	r14	
    aa5a:	0e 81       	sub	r1,	r14	
  return x;
}

inline static uint32_t load32(uint8_t *b) {
  uint32_t x;
  memcpy(&x, b, 4);
    aa5c:	81 4e 68 00 	mov	r14,	104(r1)	;0x0068(r1)
    aa60:	1f 41 68 00 	mov	104(r1),r15	;0x0068(r1)
    aa64:	0f 55       	add	r5,	r15	
    aa66:	f1 4f 60 00 	mov.b	@r15+,	96(r1)	;0x0060(r1)
    aa6a:	f1 4f 61 00 	mov.b	@r15+,	97(r1)	;0x0061(r1)
    aa6e:	f1 4f 62 00 	mov.b	@r15+,	98(r1)	;0x0062(r1)
    aa72:	e1 4f 63 00 	mov.b	@r15,	99(r1)	;0x0063(r1)
  return x;
    aa76:	1e 41 62 00 	mov	98(r1),	r14	;0x0062(r1)
Hacl_Hash_Lib_LoadStore_uint32s_from_be_bytes(uint32_t *output, uint8_t *input, uint32_t len)
{
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
  {
    uint8_t *x0 = input + (uint32_t)4U * i;
    uint32_t inputi = load32_be(x0);
    aa7a:	5f 41 60 00 	mov.b	96(r1),	r15	;0x0060(r1)
    aa7e:	81 43 64 00 	mov	#0,	100(r1)	;r3 As==00, 0x0064(r1)
    aa82:	8f 10       	swpb	r15		
    aa84:	81 4f 66 00 	mov	r15,	102(r1)	;0x0066(r1)
    aa88:	0f 4e       	mov	r14,	r15	
    aa8a:	8f 10       	swpb	r15		
    aa8c:	46 4f       	mov.b	r15,	r6	
    aa8e:	07 43       	clr	r7		
    aa90:	18 41 64 00 	mov	100(r1),r8	;0x0064(r1)
    aa94:	19 41 66 00 	mov	102(r1),r9	;0x0066(r1)
    aa98:	08 d6       	bis	r6,	r8	
    aa9a:	09 d7       	bis	r7,	r9	
    aa9c:	1c 41 60 00 	mov	96(r1),	r12	;0x0060(r1)
    aaa0:	0d 4e       	mov	r14,	r13	
    aaa2:	8c 10       	swpb	r12		
    aaa4:	8d 10       	swpb	r13		
    aaa6:	4c ed       	xor.b	r13,	r12	
    aaa8:	0c ed       	xor	r13,	r12	
    aaaa:	4d 4d       	mov.b	r13,	r13	
    aaac:	3c f0 00 ff 	and	#-256,	r12	;#0xff00
    aab0:	0d f3       	and	#0,	r13	;r3 As==00
    aab2:	08 dc       	bis	r12,	r8	
    aab4:	09 dd       	bis	r13,	r9	
    aab6:	1a 41 60 00 	mov	96(r1),	r10	;0x0060(r1)
    aaba:	0b 4e       	mov	r14,	r11	
    aabc:	4b ea       	xor.b	r10,	r11	
    aabe:	0b ea       	xor	r10,	r11	
    aac0:	8b 10       	swpb	r11		
    aac2:	4a 4a       	mov.b	r10,	r10	
    aac4:	8a 10       	swpb	r10		
    aac6:	0c 4a       	mov	r10,	r12	
    aac8:	0d 4b       	mov	r11,	r13	
    aaca:	0c f3       	and	#0,	r12	;r3 As==00
    aacc:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    aad0:	0a 48       	mov	r8,	r10	
    aad2:	0b 49       	mov	r9,	r11	
    aad4:	0a dc       	bis	r12,	r10	
    aad6:	0b dd       	bis	r13,	r11	
    aad8:	85 4a 00 00 	mov	r10,	0(r5)	;0x0000(r5)
    aadc:	85 4b 02 00 	mov	r11,	2(r5)	;0x0002(r5)
    output[i] = inputi;
    aae0:	25 52       	add	#4,	r5	;r2 As==10
#include "Hacl_HMAC_SHA2_256.h"

static void
Hacl_Hash_Lib_LoadStore_uint32s_from_be_bytes(uint32_t *output, uint8_t *input, uint32_t len)
{
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
    aae2:	05 94       	cmp	r4,	r5	
    aae4:	bd 23       	jnz	$-132    	;abs 0xaa60

static void Hacl_Impl_SHA2_256_update(uint32_t *state, uint8_t *data)
{
  uint32_t data_w[16U] = { 0U };
  Hacl_Hash_Lib_LoadStore_uint32s_from_be_bytes(data_w, data, (uint32_t)16U);
  uint32_t *hash_w = state + (uint32_t)128U;
    aae6:	1b 41 98 00 	mov	152(r1),r11	;0x0098(r1)
    aaea:	3b 50 00 02 	add	#512,	r11	;#0x0200
    aaee:	81 4b 9a 00 	mov	r11,	154(r1)	;0x009a(r1)
    aaf2:	0c 41       	mov	r1,	r12	
  uint32_t *ws_w = state + (uint32_t)64U;
    aaf4:	1a 41 98 00 	mov	152(r1),r10	;0x0098(r1)
    aaf8:	3a 50 00 01 	add	#256,	r10	;#0x0100
    aafc:	81 4a 6c 00 	mov	r10,	108(r1)	;0x006c(r1)
    ab00:	0d 4a       	mov	r10,	r13	
  uint32_t *k_w = state;
  uint32_t *counter_w = state + (uint32_t)136U;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)16U; i = i + (uint32_t)1U)
  {
    uint32_t b = data_w[i];
    ws_w[i] = b;
    ab02:	bd 4c 00 00 	mov	@r12+,	0(r13)	;0x0000(r13)
    ab06:	bd 4c 02 00 	mov	@r12+,	2(r13)	;0x0002(r13)
    ab0a:	2d 52       	add	#4,	r13	;r2 As==10
  Hacl_Hash_Lib_LoadStore_uint32s_from_be_bytes(data_w, data, (uint32_t)16U);
  uint32_t *hash_w = state + (uint32_t)128U;
  uint32_t *ws_w = state + (uint32_t)64U;
  uint32_t *k_w = state;
  uint32_t *counter_w = state + (uint32_t)136U;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)16U; i = i + (uint32_t)1U)
    ab0c:	0c 94       	cmp	r4,	r12	
    ab0e:	f9 23       	jnz	$-12     	;abs 0xab02
    ab10:	1f 41 98 00 	mov	152(r1),r15	;0x0098(r1)
    ab14:	0e 43       	clr	r14		
    ab16:	81 4e 68 00 	mov	r14,	104(r1)	;0x0068(r1)
    ws_w[i] = b;
  }
  for (uint32_t i = (uint32_t)16U; i < (uint32_t)64U; i = i + (uint32_t)1U)
  {
    uint32_t t16 = ws_w[i - (uint32_t)16U];
    uint32_t t15 = ws_w[i - (uint32_t)15U];
    ab1a:	1e 4f 06 01 	mov	262(r15),r14	;0x0106(r15)
    uint32_t t7 = ws_w[i - (uint32_t)7U];
    uint32_t t2 = ws_w[i - (uint32_t)2U];
    ab1e:	16 4f 38 01 	mov	312(r15),r6	;0x0138(r15)
    ab22:	17 4f 3a 01 	mov	314(r15),r7	;0x013a(r15)
    ws_w[i] =
      ((t2 >> (uint32_t)17U | t2 << ((uint32_t)32U - (uint32_t)17U))
      ^ ((t2 >> (uint32_t)19U | t2 << ((uint32_t)32U - (uint32_t)19U)) ^ t2 >> (uint32_t)10U))
      +
    ab26:	18 4f 24 01 	mov	292(r15),r8	;0x0124(r15)
    ab2a:	19 4f 26 01 	mov	294(r15),r9	;0x0126(r15)
    ab2e:	18 5f 00 01 	add	256(r15),r8	;0x0100(r15)
    ab32:	19 6f 02 01 	addc	258(r15),r9	;0x0102(r15)
    uint32_t t15 = ws_w[i - (uint32_t)15U];
    uint32_t t7 = ws_w[i - (uint32_t)7U];
    uint32_t t2 = ws_w[i - (uint32_t)2U];
    ws_w[i] =
      ((t2 >> (uint32_t)17U | t2 << ((uint32_t)32U - (uint32_t)17U))
      ^ ((t2 >> (uint32_t)19U | t2 << ((uint32_t)32U - (uint32_t)19U)) ^ t2 >> (uint32_t)10U))
    ab36:	0a 46       	mov	r6,	r10	
    ab38:	12 c3       	clrc			
    ab3a:	0a 10       	rrc	r10		
    ab3c:	12 c3       	clrc			
    ab3e:	0a 10       	rrc	r10		
    ab40:	12 c3       	clrc			
    ab42:	0a 10       	rrc	r10		
    ab44:	4d 47       	mov.b	r7,	r13	
    ab46:	8d 10       	swpb	r13		
    ab48:	0d 5d       	rla	r13		
    ab4a:	0d 5d       	rla	r13		
    ab4c:	0d 5d       	rla	r13		
    ab4e:	0d 5d       	rla	r13		
    ab50:	0d 5d       	rla	r13		
    ab52:	0a dd       	bis	r13,	r10	
    ab54:	81 4a 70 00 	mov	r10,	112(r1)	;0x0070(r1)
    ab58:	0a 47       	mov	r7,	r10	
    ab5a:	12 c3       	clrc			
    ab5c:	0a 10       	rrc	r10		
    ab5e:	12 c3       	clrc			
    ab60:	0a 10       	rrc	r10		
    ab62:	12 c3       	clrc			
    ab64:	0a 10       	rrc	r10		
    ab66:	4d 46       	mov.b	r6,	r13	
    ab68:	8d 10       	swpb	r13		
    ab6a:	0d 5d       	rla	r13		
    ab6c:	0d 5d       	rla	r13		
    ab6e:	0d 5d       	rla	r13		
    ab70:	0d 5d       	rla	r13		
    ab72:	0d 5d       	rla	r13		
    ab74:	0a dd       	bis	r13,	r10	
    ab76:	81 4a 6e 00 	mov	r10,	110(r1)	;0x006e(r1)
    uint32_t t16 = ws_w[i - (uint32_t)16U];
    uint32_t t15 = ws_w[i - (uint32_t)15U];
    uint32_t t7 = ws_w[i - (uint32_t)7U];
    uint32_t t2 = ws_w[i - (uint32_t)2U];
    ws_w[i] =
      ((t2 >> (uint32_t)17U | t2 << ((uint32_t)32U - (uint32_t)17U))
    ab7a:	0a 46       	mov	r6,	r10	
    ab7c:	12 c3       	clrc			
    ab7e:	0a 10       	rrc	r10		
    ab80:	0d 47       	mov	r7,	r13	
    ab82:	0d 11       	rra	r13		
    ab84:	0d 43       	clr	r13		
    ab86:	0d 10       	rrc	r13		
    ab88:	0a dd       	bis	r13,	r10	
    ab8a:	81 4a 74 00 	mov	r10,	116(r1)	;0x0074(r1)
    ab8e:	0a 47       	mov	r7,	r10	
    ab90:	12 c3       	clrc			
    ab92:	0a 10       	rrc	r10		
    ab94:	0d 46       	mov	r6,	r13	
    ab96:	0d 11       	rra	r13		
    ab98:	0d 43       	clr	r13		
    ab9a:	0d 10       	rrc	r13		
    ab9c:	0a dd       	bis	r13,	r10	
    ab9e:	81 4a 72 00 	mov	r10,	114(r1)	;0x0072(r1)
      ^ ((t2 >> (uint32_t)19U | t2 << ((uint32_t)32U - (uint32_t)19U)) ^ t2 >> (uint32_t)10U))
    aba2:	1c 41 6e 00 	mov	110(r1),r12	;0x006e(r1)
    aba6:	1d 41 70 00 	mov	112(r1),r13	;0x0070(r1)
    abaa:	1c e1 72 00 	xor	114(r1),r12	;0x0072(r1)
    abae:	1d e1 74 00 	xor	116(r1),r13	;0x0074(r1)
    abb2:	0a 46       	mov	r6,	r10	
    abb4:	0b 47       	mov	r7,	r11	
    abb6:	8a 10       	swpb	r10		
    abb8:	8b 10       	swpb	r11		
    abba:	4a eb       	xor.b	r11,	r10	
    abbc:	0a eb       	xor	r11,	r10	
    abbe:	4b 4b       	mov.b	r11,	r11	
    abc0:	12 c3       	clrc			
    abc2:	0b 10       	rrc	r11		
    abc4:	0a 10       	rrc	r10		
    abc6:	12 c3       	clrc			
    abc8:	0b 10       	rrc	r11		
    abca:	0a 10       	rrc	r10		
    abcc:	0c ea       	xor	r10,	r12	
    abce:	0d eb       	xor	r11,	r13	
      +
        t7
        +
    abd0:	06 48       	mov	r8,	r6	
    abd2:	07 49       	mov	r9,	r7	
    abd4:	06 5c       	add	r12,	r6	
    abd6:	07 6d       	addc	r13,	r7	
          ((t15 >> (uint32_t)7U | t15 << ((uint32_t)32U - (uint32_t)7U))
          ^ ((t15 >> (uint32_t)18U | t15 << ((uint32_t)32U - (uint32_t)18U)) ^ t15 >> (uint32_t)3U))
    abd8:	1a 4f 04 01 	mov	260(r15),r10	;0x0104(r15)
    abdc:	12 c3       	clrc			
    abde:	0a 10       	rrc	r10		
    abe0:	12 c3       	clrc			
    abe2:	0a 10       	rrc	r10		
    abe4:	4d 4e       	mov.b	r14,	r13	
    abe6:	8d 10       	swpb	r13		
    abe8:	0d 5d       	rla	r13		
    abea:	0d 5d       	rla	r13		
    abec:	0d 5d       	rla	r13		
    abee:	0d 5d       	rla	r13		
    abf0:	0d 5d       	rla	r13		
    abf2:	0d 5d       	rla	r13		
    abf4:	0a dd       	bis	r13,	r10	
    abf6:	81 4a 78 00 	mov	r10,	120(r1)	;0x0078(r1)
    abfa:	0a 4e       	mov	r14,	r10	
    abfc:	12 c3       	clrc			
    abfe:	0a 10       	rrc	r10		
    ac00:	12 c3       	clrc			
    ac02:	0a 10       	rrc	r10		
    ac04:	5d 4f 04 01 	mov.b	260(r15),r13	;0x0104(r15)
    ac08:	8d 10       	swpb	r13		
    ac0a:	0d 5d       	rla	r13		
    ac0c:	0d 5d       	rla	r13		
    ac0e:	0d 5d       	rla	r13		
    ac10:	0d 5d       	rla	r13		
    ac12:	0d 5d       	rla	r13		
    ac14:	0d 5d       	rla	r13		
    ac16:	0a dd       	bis	r13,	r10	
    ac18:	81 4a 76 00 	mov	r10,	118(r1)	;0x0076(r1)
      ((t2 >> (uint32_t)17U | t2 << ((uint32_t)32U - (uint32_t)17U))
      ^ ((t2 >> (uint32_t)19U | t2 << ((uint32_t)32U - (uint32_t)19U)) ^ t2 >> (uint32_t)10U))
      +
        t7
        +
          ((t15 >> (uint32_t)7U | t15 << ((uint32_t)32U - (uint32_t)7U))
    ac1c:	5a 4f 04 01 	mov.b	260(r15),r10	;0x0104(r15)
    ac20:	8a 10       	swpb	r10		
    ac22:	0a 5a       	rla	r10		
    ac24:	0d 4e       	mov	r14,	r13	
    ac26:	12 c3       	clrc			
    ac28:	0d 10       	rrc	r13		
    ac2a:	12 c3       	clrc			
    ac2c:	0d 10       	rrc	r13		
    ac2e:	12 c3       	clrc			
    ac30:	0d 10       	rrc	r13		
    ac32:	12 c3       	clrc			
    ac34:	0d 10       	rrc	r13		
    ac36:	12 c3       	clrc			
    ac38:	0d 10       	rrc	r13		
    ac3a:	12 c3       	clrc			
    ac3c:	0d 10       	rrc	r13		
    ac3e:	12 c3       	clrc			
    ac40:	0d 10       	rrc	r13		
    ac42:	05 4a       	mov	r10,	r5	
    ac44:	05 dd       	bis	r13,	r5	
    ac46:	4a 4e       	mov.b	r14,	r10	
    ac48:	8a 10       	swpb	r10		
    ac4a:	0a 5a       	rla	r10		
    ac4c:	1d 4f 04 01 	mov	260(r15),r13	;0x0104(r15)
    ac50:	12 c3       	clrc			
    ac52:	0d 10       	rrc	r13		
    ac54:	12 c3       	clrc			
    ac56:	0d 10       	rrc	r13		
    ac58:	12 c3       	clrc			
    ac5a:	0d 10       	rrc	r13		
    ac5c:	12 c3       	clrc			
    ac5e:	0d 10       	rrc	r13		
    ac60:	12 c3       	clrc			
    ac62:	0d 10       	rrc	r13		
    ac64:	12 c3       	clrc			
    ac66:	0d 10       	rrc	r13		
    ac68:	12 c3       	clrc			
    ac6a:	0d 10       	rrc	r13		
    ac6c:	04 4a       	mov	r10,	r4	
    ac6e:	04 dd       	bis	r13,	r4	
          ^ ((t15 >> (uint32_t)18U | t15 << ((uint32_t)32U - (uint32_t)18U)) ^ t15 >> (uint32_t)3U))
    ac70:	18 41 76 00 	mov	118(r1),r8	;0x0076(r1)
    ac74:	19 41 78 00 	mov	120(r1),r9	;0x0078(r1)
    ac78:	08 e4       	xor	r4,	r8	
    ac7a:	09 e5       	xor	r5,	r9	
    ac7c:	1a 4f 04 01 	mov	260(r15),r10	;0x0104(r15)
    ac80:	0b 4e       	mov	r14,	r11	
    ac82:	12 c3       	clrc			
    ac84:	0b 10       	rrc	r11		
    ac86:	0a 10       	rrc	r10		
    ac88:	12 c3       	clrc			
    ac8a:	0b 10       	rrc	r11		
    ac8c:	0a 10       	rrc	r10		
    ac8e:	12 c3       	clrc			
    ac90:	0b 10       	rrc	r11		
    ac92:	0a 10       	rrc	r10		
    ac94:	0c 48       	mov	r8,	r12	
    ac96:	0d 49       	mov	r9,	r13	
    ac98:	0c ea       	xor	r10,	r12	
    ac9a:	0d eb       	xor	r11,	r13	
          + t16;
    ac9c:	0a 46       	mov	r6,	r10	
    ac9e:	0b 47       	mov	r7,	r11	
    aca0:	0a 5c       	add	r12,	r10	
    aca2:	0b 6d       	addc	r13,	r11	
    aca4:	8f 4a 40 01 	mov	r10,	320(r15);0x0140(r15)
    aca8:	8f 4b 42 01 	mov	r11,	322(r15);0x0142(r15)
  {
    uint32_t t16 = ws_w[i - (uint32_t)16U];
    uint32_t t15 = ws_w[i - (uint32_t)15U];
    uint32_t t7 = ws_w[i - (uint32_t)7U];
    uint32_t t2 = ws_w[i - (uint32_t)2U];
    ws_w[i] =
    acac:	a1 52 68 00 	add	#4,	104(r1)	;r2 As==10, 0x0068(r1)
    acb0:	2f 52       	add	#4,	r15	;r2 As==10
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)16U; i = i + (uint32_t)1U)
  {
    uint32_t b = data_w[i];
    ws_w[i] = b;
  }
  for (uint32_t i = (uint32_t)16U; i < (uint32_t)64U; i = i + (uint32_t)1U)
    acb2:	b1 90 c0 00 	cmp	#192,	104(r1)	;#0x00c0, 0x0068(r1)
    acb6:	68 00 
    acb8:	30 23       	jnz	$-414    	;abs 0xab1a
        +
          ((t15 >> (uint32_t)7U | t15 << ((uint32_t)32U - (uint32_t)7U))
          ^ ((t15 >> (uint32_t)18U | t15 << ((uint32_t)32U - (uint32_t)18U)) ^ t15 >> (uint32_t)3U))
          + t16;
  }
  uint32_t hash_0[8U] = { 0U };
    acba:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    acbe:	0e 43       	clr	r14		
    acc0:	0f 41       	mov	r1,	r15	
    acc2:	3f 50 40 00 	add	#64,	r15	;#0x0040
    acc6:	b0 12 52 b7 	call	#0xb752	
  memcpy(hash_0, hash_w, (uint32_t)8U * sizeof hash_w[0U]);
    acca:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    acce:	1e 41 9a 00 	mov	154(r1),r14	;0x009a(r1)
    acd2:	0f 41       	mov	r1,	r15	
    acd4:	3f 50 40 00 	add	#64,	r15	;#0x0040
    acd8:	b0 12 58 b6 	call	#0xb658	
    acdc:	18 41 50 00 	mov	80(r1),	r8	;0x0050(r1)
    ace0:	19 41 52 00 	mov	82(r1),	r9	;0x0052(r1)
  p2[1U] = (uint32_t)0x9b05688cU;
  p2[2U] = (uint32_t)0x1f83d9abU;
  p2[3U] = (uint32_t)0x5be0cd19U;
}

static void Hacl_Impl_SHA2_256_update(uint32_t *state, uint8_t *data)
    ace4:	1b 41 98 00 	mov	152(r1),r11	;0x0098(r1)
    ace8:	3b 50 00 02 	add	#512,	r11	;#0x0200
    acec:	81 4b 96 00 	mov	r11,	150(r1)	;0x0096(r1)
    acf0:	04 3c       	jmp	$+10     	;abs 0xacfa
    uint32_t *p2 = hash_0 + (uint32_t)4U;
    p1[0U] = x1;
    p1[1U] = a;
    p1[2U] = b;
    p1[3U] = c;
    p2[0U] = x5;
    acf2:	18 41 92 00 	mov	146(r1),r8	;0x0092(r1)
    acf6:	19 41 94 00 	mov	148(r1),r9	;0x0094(r1)
  }
  uint32_t hash_0[8U] = { 0U };
  memcpy(hash_0, hash_w, (uint32_t)8U * sizeof hash_w[0U]);
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)64U; i = i + (uint32_t)1U)
  {
    uint32_t a = hash_0[0U];
    acfa:	16 41 40 00 	mov	64(r1),	r6	;0x0040(r1)
    acfe:	17 41 42 00 	mov	66(r1),	r7	;0x0042(r1)
    uint32_t b = hash_0[1U];
    ad02:	91 41 44 00 	mov	68(r1),	100(r1)	;0x0044(r1), 0x0064(r1)
    ad06:	64 00 
    ad08:	91 41 46 00 	mov	70(r1),	102(r1)	;0x0046(r1), 0x0066(r1)
    ad0c:	66 00 
    uint32_t c = hash_0[2U];
    ad0e:	91 41 48 00 	mov	72(r1),	104(r1)	;0x0048(r1), 0x0068(r1)
    ad12:	68 00 
    ad14:	91 41 4a 00 	mov	74(r1),	106(r1)	;0x004a(r1), 0x006a(r1)
    ad18:	6a 00 
    uint32_t d = hash_0[3U];
    uint32_t e = hash_0[4U];
    uint32_t f1 = hash_0[5U];
    ad1a:	91 41 54 00 	mov	84(r1),	110(r1)	;0x0054(r1), 0x006e(r1)
    ad1e:	6e 00 
    ad20:	91 41 56 00 	mov	86(r1),	112(r1)	;0x0056(r1), 0x0070(r1)
    ad24:	70 00 
    uint32_t g = hash_0[6U];
    ad26:	91 41 58 00 	mov	88(r1),	114(r1)	;0x0058(r1), 0x0072(r1)
    ad2a:	72 00 
    ad2c:	91 41 5a 00 	mov	90(r1),	116(r1)	;0x005a(r1), 0x0074(r1)
    ad30:	74 00 
    uint32_t kt = k_w[i];
    uint32_t wst = ws_w[i];
    uint32_t
    t1 =
      h
      +
    ad32:	1a 41 6c 00 	mov	108(r1),r10	;0x006c(r1)
    ad36:	1c 4a 00 ff 	mov	-256(r10),r12	;0xff00(r10)
    ad3a:	1d 4a 02 ff 	mov	-254(r10),r13	;0xff02(r10)
    ad3e:	2c 5a       	add	@r10,	r12	
    ad40:	1d 6a 02 00 	addc	2(r10),	r13	;0x0002(r10)
        ((e >> (uint32_t)6U | e << ((uint32_t)32U - (uint32_t)6U))
        ^
          ((e >> (uint32_t)11U | e << ((uint32_t)32U - (uint32_t)11U))
          ^ (e >> (uint32_t)25U | e << ((uint32_t)32U - (uint32_t)25U))))
      + ((e & f1) ^ (~e & g))
    ad44:	0a 4c       	mov	r12,	r10	
    ad46:	0b 4d       	mov	r13,	r11	
    ad48:	1a 51 5c 00 	add	92(r1),	r10	;0x005c(r1)
    ad4c:	1b 61 5e 00 	addc	94(r1),	r11	;0x005e(r1)
    t1 =
      h
      +
        ((e >> (uint32_t)6U | e << ((uint32_t)32U - (uint32_t)6U))
        ^
          ((e >> (uint32_t)11U | e << ((uint32_t)32U - (uint32_t)11U))
    ad50:	0d 49       	mov	r9,	r13	
    ad52:	0d 5d       	rla	r13		
    ad54:	0d 5d       	rla	r13		
    ad56:	0d 5d       	rla	r13		
    ad58:	0d 5d       	rla	r13		
    ad5a:	0d 5d       	rla	r13		
    ad5c:	0f 48       	mov	r8,	r15	
    ad5e:	8f 10       	swpb	r15		
    ad60:	4f 4f       	mov.b	r15,	r15	
    ad62:	12 c3       	clrc			
    ad64:	0f 10       	rrc	r15		
    ad66:	12 c3       	clrc			
    ad68:	0f 10       	rrc	r15		
    ad6a:	12 c3       	clrc			
    ad6c:	0f 10       	rrc	r15		
    ad6e:	0d df       	bis	r15,	r13	
    ad70:	81 4d 7a 00 	mov	r13,	122(r1)	;0x007a(r1)
    ad74:	0d 48       	mov	r8,	r13	
    ad76:	0d 5d       	rla	r13		
    ad78:	0d 5d       	rla	r13		
    ad7a:	0d 5d       	rla	r13		
    ad7c:	0d 5d       	rla	r13		
    ad7e:	0d 5d       	rla	r13		
    ad80:	0f 49       	mov	r9,	r15	
    ad82:	8f 10       	swpb	r15		
    ad84:	4f 4f       	mov.b	r15,	r15	
    ad86:	12 c3       	clrc			
    ad88:	0f 10       	rrc	r15		
    ad8a:	12 c3       	clrc			
    ad8c:	0f 10       	rrc	r15		
    ad8e:	12 c3       	clrc			
    ad90:	0f 10       	rrc	r15		
    ad92:	0d df       	bis	r15,	r13	
    ad94:	81 4d 7c 00 	mov	r13,	124(r1)	;0x007c(r1)
    uint32_t wst = ws_w[i];
    uint32_t
    t1 =
      h
      +
        ((e >> (uint32_t)6U | e << ((uint32_t)32U - (uint32_t)6U))
    ad98:	4d 49       	mov.b	r9,	r13	
    ad9a:	8d 10       	swpb	r13		
    ad9c:	0d 5d       	rla	r13		
    ad9e:	0d 5d       	rla	r13		
    ada0:	0f 48       	mov	r8,	r15	
    ada2:	12 c3       	clrc			
    ada4:	0f 10       	rrc	r15		
    ada6:	12 c3       	clrc			
    ada8:	0f 10       	rrc	r15		
    adaa:	12 c3       	clrc			
    adac:	0f 10       	rrc	r15		
    adae:	12 c3       	clrc			
    adb0:	0f 10       	rrc	r15		
    adb2:	12 c3       	clrc			
    adb4:	0f 10       	rrc	r15		
    adb6:	12 c3       	clrc			
    adb8:	0f 10       	rrc	r15		
    adba:	0d df       	bis	r15,	r13	
    adbc:	81 4d 7e 00 	mov	r13,	126(r1)	;0x007e(r1)
    adc0:	4d 48       	mov.b	r8,	r13	
    adc2:	8d 10       	swpb	r13		
    adc4:	0d 5d       	rla	r13		
    adc6:	0d 5d       	rla	r13		
    adc8:	0f 49       	mov	r9,	r15	
    adca:	12 c3       	clrc			
    adcc:	0f 10       	rrc	r15		
    adce:	12 c3       	clrc			
    add0:	0f 10       	rrc	r15		
    add2:	12 c3       	clrc			
    add4:	0f 10       	rrc	r15		
    add6:	12 c3       	clrc			
    add8:	0f 10       	rrc	r15		
    adda:	12 c3       	clrc			
    addc:	0f 10       	rrc	r15		
    adde:	12 c3       	clrc			
    ade0:	0f 10       	rrc	r15		
    ade2:	0d df       	bis	r15,	r13	
    ade4:	81 4d 80 00 	mov	r13,	128(r1)	;0x0080(r1)
        ^
          ((e >> (uint32_t)11U | e << ((uint32_t)32U - (uint32_t)11U))
          ^ (e >> (uint32_t)25U | e << ((uint32_t)32U - (uint32_t)25U))))
    ade8:	14 41 7a 00 	mov	122(r1),r4	;0x007a(r1)
    adec:	15 41 7c 00 	mov	124(r1),r5	;0x007c(r1)
    adf0:	14 e1 7e 00 	xor	126(r1),r4	;0x007e(r1)
    adf4:	15 e1 80 00 	xor	128(r1),r5	;0x0080(r1)
    adf8:	0d 49       	mov	r9,	r13	
    adfa:	8d 10       	swpb	r13		
    adfc:	4d 4d       	mov.b	r13,	r13	
    adfe:	12 c3       	clrc			
    ae00:	0d 10       	rrc	r13		
    ae02:	0f 48       	mov	r8,	r15	
    ae04:	0f 5f       	rla	r15		
    ae06:	0f 5f       	rla	r15		
    ae08:	0f 5f       	rla	r15		
    ae0a:	0f 5f       	rla	r15		
    ae0c:	0f 5f       	rla	r15		
    ae0e:	0f 5f       	rla	r15		
    ae10:	0f 5f       	rla	r15		
    ae12:	0d df       	bis	r15,	r13	
    ae14:	81 4d 82 00 	mov	r13,	130(r1)	;0x0082(r1)
    ae18:	0d 48       	mov	r8,	r13	
    ae1a:	8d 10       	swpb	r13		
    ae1c:	4d 4d       	mov.b	r13,	r13	
    ae1e:	12 c3       	clrc			
    ae20:	0d 10       	rrc	r13		
    ae22:	0f 49       	mov	r9,	r15	
    ae24:	0f 5f       	rla	r15		
    ae26:	0f 5f       	rla	r15		
    ae28:	0f 5f       	rla	r15		
    ae2a:	0f 5f       	rla	r15		
    ae2c:	0f 5f       	rla	r15		
    ae2e:	0f 5f       	rla	r15		
    ae30:	0f 5f       	rla	r15		
    ae32:	0d df       	bis	r15,	r13	
    ae34:	81 4d 84 00 	mov	r13,	132(r1)	;0x0084(r1)
    uint32_t
    t1 =
      h
      +
        ((e >> (uint32_t)6U | e << ((uint32_t)32U - (uint32_t)6U))
        ^
    ae38:	1c 41 82 00 	mov	130(r1),r12	;0x0082(r1)
    ae3c:	1d 41 84 00 	mov	132(r1),r13	;0x0084(r1)
    ae40:	0c e4       	xor	r4,	r12	
    ae42:	0d e5       	xor	r5,	r13	
          ((e >> (uint32_t)11U | e << ((uint32_t)32U - (uint32_t)11U))
          ^ (e >> (uint32_t)25U | e << ((uint32_t)32U - (uint32_t)25U))))
      + ((e & f1) ^ (~e & g))
      + kt
    ae44:	0a 5c       	add	r12,	r10	
    ae46:	0b 6d       	addc	r13,	r11	
      +
        ((e >> (uint32_t)6U | e << ((uint32_t)32U - (uint32_t)6U))
        ^
          ((e >> (uint32_t)11U | e << ((uint32_t)32U - (uint32_t)11U))
          ^ (e >> (uint32_t)25U | e << ((uint32_t)32U - (uint32_t)25U))))
      + ((e & f1) ^ (~e & g))
    ae48:	1e 41 72 00 	mov	114(r1),r14	;0x0072(r1)
    ae4c:	1f 41 74 00 	mov	116(r1),r15	;0x0074(r1)
    ae50:	0e c8       	bic	r8,	r14	
    ae52:	0f c9       	bic	r9,	r15	
    ae54:	1c 41 6e 00 	mov	110(r1),r12	;0x006e(r1)
    ae58:	1d 41 70 00 	mov	112(r1),r13	;0x0070(r1)
    ae5c:	0c f8       	and	r8,	r12	
    ae5e:	0d f9       	and	r9,	r13	
    ae60:	0e ec       	xor	r12,	r14	
    ae62:	0f ed       	xor	r13,	r15	
    uint32_t g = hash_0[6U];
    uint32_t h = hash_0[7U];
    uint32_t kt = k_w[i];
    uint32_t wst = ws_w[i];
    uint32_t
    t1 =
    ae64:	0c 4a       	mov	r10,	r12	
    ae66:	0d 4b       	mov	r11,	r13	
    ae68:	0c 5e       	add	r14,	r12	
    ae6a:	0d 6f       	addc	r15,	r13	
    ae6c:	81 4c 76 00 	mov	r12,	118(r1)	;0x0076(r1)
    ae70:	81 4d 78 00 	mov	r13,	120(r1)	;0x0078(r1)
      ^
        ((a >> (uint32_t)13U | a << ((uint32_t)32U - (uint32_t)13U))
        ^ (a >> (uint32_t)22U | a << ((uint32_t)32U - (uint32_t)22U))))
      + ((a & b) ^ ((a & c) ^ (b & c)));
    uint32_t x1 = t1 + t2;
    uint32_t x5 = d + t1;
    ae74:	1c 51 4c 00 	add	76(r1),	r12	;0x004c(r1)
    ae78:	1d 61 4e 00 	addc	78(r1),	r13	;0x004e(r1)
    ae7c:	81 4c 92 00 	mov	r12,	146(r1)	;0x0092(r1)
    ae80:	81 4d 94 00 	mov	r13,	148(r1)	;0x0094(r1)
    t2 =
      ((a >> (uint32_t)2U | a << ((uint32_t)32U - (uint32_t)2U))
      ^
        ((a >> (uint32_t)13U | a << ((uint32_t)32U - (uint32_t)13U))
        ^ (a >> (uint32_t)22U | a << ((uint32_t)32U - (uint32_t)22U))))
      + ((a & b) ^ ((a & c) ^ (b & c)));
    ae84:	1e 41 64 00 	mov	100(r1),r14	;0x0064(r1)
    ae88:	1f 41 66 00 	mov	102(r1),r15	;0x0066(r1)
    ae8c:	1e e1 68 00 	xor	104(r1),r14	;0x0068(r1)
    ae90:	1f e1 6a 00 	xor	106(r1),r15	;0x006a(r1)
    ae94:	0a 4e       	mov	r14,	r10	
    ae96:	0b 4f       	mov	r15,	r11	
    ae98:	0a f6       	and	r6,	r10	
    ae9a:	0b f7       	and	r7,	r11	
    ae9c:	1c 41 68 00 	mov	104(r1),r12	;0x0068(r1)
    aea0:	1d 41 6a 00 	mov	106(r1),r13	;0x006a(r1)
    aea4:	1c f1 64 00 	and	100(r1),r12	;0x0064(r1)
    aea8:	1d f1 66 00 	and	102(r1),r13	;0x0066(r1)
    aeac:	0a ec       	xor	r12,	r10	
    aeae:	0b ed       	xor	r13,	r11	
      + wst;
    uint32_t
    t2 =
      ((a >> (uint32_t)2U | a << ((uint32_t)32U - (uint32_t)2U))
      ^
        ((a >> (uint32_t)13U | a << ((uint32_t)32U - (uint32_t)13U))
    aeb0:	0d 46       	mov	r6,	r13	
    aeb2:	0d 5d       	rla	r13		
    aeb4:	0d 5d       	rla	r13		
    aeb6:	0d 5d       	rla	r13		
    aeb8:	0f 47       	mov	r7,	r15	
    aeba:	8f 10       	swpb	r15		
    aebc:	4f 4f       	mov.b	r15,	r15	
    aebe:	12 c3       	clrc			
    aec0:	0f 10       	rrc	r15		
    aec2:	12 c3       	clrc			
    aec4:	0f 10       	rrc	r15		
    aec6:	12 c3       	clrc			
    aec8:	0f 10       	rrc	r15		
    aeca:	12 c3       	clrc			
    aecc:	0f 10       	rrc	r15		
    aece:	12 c3       	clrc			
    aed0:	0f 10       	rrc	r15		
    aed2:	0d df       	bis	r15,	r13	
    aed4:	81 4d 88 00 	mov	r13,	136(r1)	;0x0088(r1)
    aed8:	0d 47       	mov	r7,	r13	
    aeda:	0d 5d       	rla	r13		
    aedc:	0d 5d       	rla	r13		
    aede:	0d 5d       	rla	r13		
    aee0:	0f 46       	mov	r6,	r15	
    aee2:	8f 10       	swpb	r15		
    aee4:	4f 4f       	mov.b	r15,	r15	
    aee6:	12 c3       	clrc			
    aee8:	0f 10       	rrc	r15		
    aeea:	12 c3       	clrc			
    aeec:	0f 10       	rrc	r15		
    aeee:	12 c3       	clrc			
    aef0:	0f 10       	rrc	r15		
    aef2:	12 c3       	clrc			
    aef4:	0f 10       	rrc	r15		
    aef6:	12 c3       	clrc			
    aef8:	0f 10       	rrc	r15		
    aefa:	0d df       	bis	r15,	r13	
    aefc:	81 4d 86 00 	mov	r13,	134(r1)	;0x0086(r1)
      + ((e & f1) ^ (~e & g))
      + kt
      + wst;
    uint32_t
    t2 =
      ((a >> (uint32_t)2U | a << ((uint32_t)32U - (uint32_t)2U))
    af00:	4d 46       	mov.b	r6,	r13	
    af02:	8d 10       	swpb	r13		
    af04:	0d 5d       	rla	r13		
    af06:	0d 5d       	rla	r13		
    af08:	0d 5d       	rla	r13		
    af0a:	0d 5d       	rla	r13		
    af0c:	0d 5d       	rla	r13		
    af0e:	0d 5d       	rla	r13		
    af10:	0f 47       	mov	r7,	r15	
    af12:	12 c3       	clrc			
    af14:	0f 10       	rrc	r15		
    af16:	12 c3       	clrc			
    af18:	0f 10       	rrc	r15		
    af1a:	0d df       	bis	r15,	r13	
    af1c:	81 4d 8c 00 	mov	r13,	140(r1)	;0x008c(r1)
    af20:	4d 47       	mov.b	r7,	r13	
    af22:	8d 10       	swpb	r13		
    af24:	0d 5d       	rla	r13		
    af26:	0d 5d       	rla	r13		
    af28:	0d 5d       	rla	r13		
    af2a:	0d 5d       	rla	r13		
    af2c:	0d 5d       	rla	r13		
    af2e:	0d 5d       	rla	r13		
    af30:	0f 46       	mov	r6,	r15	
    af32:	12 c3       	clrc			
    af34:	0f 10       	rrc	r15		
    af36:	12 c3       	clrc			
    af38:	0f 10       	rrc	r15		
    af3a:	0d df       	bis	r15,	r13	
    af3c:	81 4d 8a 00 	mov	r13,	138(r1)	;0x008a(r1)
      ^
        ((a >> (uint32_t)13U | a << ((uint32_t)32U - (uint32_t)13U))
        ^ (a >> (uint32_t)22U | a << ((uint32_t)32U - (uint32_t)22U))))
    af40:	14 41 86 00 	mov	134(r1),r4	;0x0086(r1)
    af44:	15 41 88 00 	mov	136(r1),r5	;0x0088(r1)
    af48:	14 e1 8a 00 	xor	138(r1),r4	;0x008a(r1)
    af4c:	15 e1 8c 00 	xor	140(r1),r5	;0x008c(r1)
    af50:	0d 4f       	mov	r15,	r13	
    af52:	12 c3       	clrc			
    af54:	0d 10       	rrc	r13		
    af56:	12 c3       	clrc			
    af58:	0d 10       	rrc	r13		
    af5a:	12 c3       	clrc			
    af5c:	0d 10       	rrc	r13		
    af5e:	12 c3       	clrc			
    af60:	0d 10       	rrc	r13		
    af62:	4f 47       	mov.b	r7,	r15	
    af64:	8f 10       	swpb	r15		
    af66:	0f 5f       	rla	r15		
    af68:	0f 5f       	rla	r15		
    af6a:	0d df       	bis	r15,	r13	
    af6c:	81 4d 90 00 	mov	r13,	144(r1)	;0x0090(r1)
    af70:	0d 47       	mov	r7,	r13	
    af72:	12 c3       	clrc			
    af74:	0d 10       	rrc	r13		
    af76:	12 c3       	clrc			
    af78:	0d 10       	rrc	r13		
    af7a:	12 c3       	clrc			
    af7c:	0d 10       	rrc	r13		
    af7e:	12 c3       	clrc			
    af80:	0d 10       	rrc	r13		
    af82:	12 c3       	clrc			
    af84:	0d 10       	rrc	r13		
    af86:	12 c3       	clrc			
    af88:	0d 10       	rrc	r13		
    af8a:	4f 46       	mov.b	r6,	r15	
    af8c:	8f 10       	swpb	r15		
    af8e:	0f 5f       	rla	r15		
    af90:	0f 5f       	rla	r15		
    af92:	0d df       	bis	r15,	r13	
    af94:	81 4d 8e 00 	mov	r13,	142(r1)	;0x008e(r1)
      + kt
      + wst;
    uint32_t
    t2 =
      ((a >> (uint32_t)2U | a << ((uint32_t)32U - (uint32_t)2U))
      ^
    af98:	1c 41 8e 00 	mov	142(r1),r12	;0x008e(r1)
    af9c:	1d 41 90 00 	mov	144(r1),r13	;0x0090(r1)
    afa0:	0c e4       	xor	r4,	r12	
    afa2:	0d e5       	xor	r5,	r13	
          ^ (e >> (uint32_t)25U | e << ((uint32_t)32U - (uint32_t)25U))))
      + ((e & f1) ^ (~e & g))
      + kt
      + wst;
    uint32_t
    t2 =
    afa4:	0e 4a       	mov	r10,	r14	
    afa6:	0f 4b       	mov	r11,	r15	
    afa8:	0e 5c       	add	r12,	r14	
    afaa:	0f 6d       	addc	r13,	r15	
      ((a >> (uint32_t)2U | a << ((uint32_t)32U - (uint32_t)2U))
      ^
        ((a >> (uint32_t)13U | a << ((uint32_t)32U - (uint32_t)13U))
        ^ (a >> (uint32_t)22U | a << ((uint32_t)32U - (uint32_t)22U))))
      + ((a & b) ^ ((a & c) ^ (b & c)));
    uint32_t x1 = t1 + t2;
    afac:	1a 41 76 00 	mov	118(r1),r10	;0x0076(r1)
    afb0:	1b 41 78 00 	mov	120(r1),r11	;0x0078(r1)
    afb4:	0a 5e       	add	r14,	r10	
    afb6:	0b 6f       	addc	r15,	r11	
    afb8:	81 4a 40 00 	mov	r10,	64(r1)	;0x0040(r1)
    afbc:	81 4b 42 00 	mov	r11,	66(r1)	;0x0042(r1)
    uint32_t x5 = d + t1;
    uint32_t *p1 = hash_0;
    uint32_t *p2 = hash_0 + (uint32_t)4U;
    p1[0U] = x1;
    p1[1U] = a;
    afc0:	81 46 44 00 	mov	r6,	68(r1)	;0x0044(r1)
    afc4:	81 47 46 00 	mov	r7,	70(r1)	;0x0046(r1)
    p1[2U] = b;
    afc8:	91 41 64 00 	mov	100(r1),72(r1)	;0x0064(r1), 0x0048(r1)
    afcc:	48 00 
    afce:	91 41 66 00 	mov	102(r1),74(r1)	;0x0066(r1), 0x004a(r1)
    afd2:	4a 00 
    p1[3U] = c;
    afd4:	91 41 68 00 	mov	104(r1),76(r1)	;0x0068(r1), 0x004c(r1)
    afd8:	4c 00 
    afda:	91 41 6a 00 	mov	106(r1),78(r1)	;0x006a(r1), 0x004e(r1)
    afde:	4e 00 
    p2[0U] = x5;
    p2[1U] = e;
    afe0:	81 48 54 00 	mov	r8,	84(r1)	;0x0054(r1)
    afe4:	81 49 56 00 	mov	r9,	86(r1)	;0x0056(r1)
    p2[2U] = f1;
    afe8:	91 41 6e 00 	mov	110(r1),88(r1)	;0x006e(r1), 0x0058(r1)
    afec:	58 00 
    afee:	91 41 70 00 	mov	112(r1),90(r1)	;0x0070(r1), 0x005a(r1)
    aff2:	5a 00 
    p2[3U] = g;
    aff4:	91 41 72 00 	mov	114(r1),92(r1)	;0x0072(r1), 0x005c(r1)
    aff8:	5c 00 
    affa:	91 41 74 00 	mov	116(r1),94(r1)	;0x0074(r1), 0x005e(r1)
    affe:	5e 00 
    b000:	a1 52 6c 00 	add	#4,	108(r1)	;r2 As==10, 0x006c(r1)
          ^ ((t15 >> (uint32_t)18U | t15 << ((uint32_t)32U - (uint32_t)18U)) ^ t15 >> (uint32_t)3U))
          + t16;
  }
  uint32_t hash_0[8U] = { 0U };
  memcpy(hash_0, hash_w, (uint32_t)8U * sizeof hash_w[0U]);
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)64U; i = i + (uint32_t)1U)
    b004:	91 91 96 00 	cmp	150(r1),108(r1)	;0x0096(r1), 0x006c(r1)
    b008:	6c 00 
    b00a:	02 24       	jz	$+6      	;abs 0xb010
    b00c:	30 40 f2 ac 	br	#0xacf2	
    b010:	91 41 92 00 	mov	146(r1),80(r1)	;0x0092(r1), 0x0050(r1)
    b014:	50 00 
    b016:	91 41 94 00 	mov	148(r1),82(r1)	;0x0094(r1), 0x0052(r1)
    b01a:	52 00 
    b01c:	1e 41 9a 00 	mov	154(r1),r14	;0x009a(r1)
    b020:	0d 41       	mov	r1,	r13	
    b022:	3d 50 40 00 	add	#64,	r13	;#0x0040
  p2[1U] = (uint32_t)0x9b05688cU;
  p2[2U] = (uint32_t)0x1f83d9abU;
  p2[3U] = (uint32_t)0x5be0cd19U;
}

static void Hacl_Impl_SHA2_256_update(uint32_t *state, uint8_t *data)
    b026:	1c 41 98 00 	mov	152(r1),r12	;0x0098(r1)
    b02a:	3c 50 20 02 	add	#544,	r12	;#0x0220
  }
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)8U; i = i + (uint32_t)1U)
  {
    uint32_t xi = hash_w[i];
    uint32_t yi = hash_0[i];
    hash_w[i] = xi + yi;
    b02e:	be 5d 00 00 	add	@r13+,	0(r14)	;0x0000(r14)
    b032:	be 6d 02 00 	addc	@r13+,	2(r14)	;0x0002(r14)
    b036:	2e 52       	add	#4,	r14	;r2 As==10
    p2[0U] = x5;
    p2[1U] = e;
    p2[2U] = f1;
    p2[3U] = g;
  }
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)8U; i = i + (uint32_t)1U)
    b038:	0e 9c       	cmp	r12,	r14	
    b03a:	f9 23       	jnz	$-12     	;abs 0xb02e
    uint32_t yi = hash_0[i];
    hash_w[i] = xi + yi;
  }
  uint32_t c0 = counter_w[0U];
  uint32_t one1 = (uint32_t)1U;
  counter_w[0U] = c0 + one1;
    b03c:	1b 41 98 00 	mov	152(r1),r11	;0x0098(r1)
    b040:	9b 53 20 02 	inc	544(r11)	;0x0220(r11)
    b044:	8b 63 22 02 	adc	546(r11)	;0x0222(r11)
}
    b048:	31 50 9c 00 	add	#156,	r1	;#0x009c
    b04c:	34 41       	pop	r4		
    b04e:	35 41       	pop	r5		
    b050:	36 41       	pop	r6		
    b052:	37 41       	pop	r7		
    b054:	38 41       	pop	r8		
    b056:	39 41       	pop	r9		
    b058:	3a 41       	pop	r10		
    b05a:	3b 41       	pop	r11		
    b05c:	30 41       	ret			

0000b05e <Hacl_Impl_SHA2_256_update_multi>:

static void Hacl_Impl_SHA2_256_update_multi(uint32_t *state, uint8_t *data, uint32_t n1)
{
    b05e:	0b 12       	push	r11		
    b060:	0a 12       	push	r10		
    b062:	09 12       	push	r9		
    b064:	08 12       	push	r8		
    b066:	07 12       	push	r7		
    b068:	06 12       	push	r6		
    b06a:	07 4f       	mov	r15,	r7	
    b06c:	08 4c       	mov	r12,	r8	
    b06e:	06 4d       	mov	r13,	r6	
  for (uint32_t i = (uint32_t)0U; i < n1; i = i + (uint32_t)1U)
    b070:	0c 93       	tst	r12		
    b072:	02 20       	jnz	$+6      	;abs 0xb078
    b074:	0d 93       	tst	r13		
    b076:	0f 24       	jz	$+32     	;abs 0xb096
    b078:	09 4e       	mov	r14,	r9	
    b07a:	0a 43       	clr	r10		
    b07c:	0b 43       	clr	r11		
  {
    uint8_t *b = data + i * (uint32_t)64U;
    Hacl_Impl_SHA2_256_update(state, b);
    b07e:	0e 49       	mov	r9,	r14	
    b080:	0f 47       	mov	r7,	r15	
    b082:	b0 12 2a aa 	call	#0xaa2a	
  counter_w[0U] = c0 + one1;
}

static void Hacl_Impl_SHA2_256_update_multi(uint32_t *state, uint8_t *data, uint32_t n1)
{
  for (uint32_t i = (uint32_t)0U; i < n1; i = i + (uint32_t)1U)
    b086:	1a 53       	inc	r10		
    b088:	0b 63       	adc	r11		
    b08a:	39 50 40 00 	add	#64,	r9	;#0x0040
    b08e:	0a 98       	cmp	r8,	r10	
    b090:	f6 23       	jnz	$-18     	;abs 0xb07e
    b092:	0b 96       	cmp	r6,	r11	
    b094:	f4 23       	jnz	$-22     	;abs 0xb07e
  {
    uint8_t *b = data + i * (uint32_t)64U;
    Hacl_Impl_SHA2_256_update(state, b);
  }
}
    b096:	36 41       	pop	r6		
    b098:	37 41       	pop	r7		
    b09a:	38 41       	pop	r8		
    b09c:	39 41       	pop	r9		
    b09e:	3a 41       	pop	r10		
    b0a0:	3b 41       	pop	r11		
    b0a2:	30 41       	ret			

0000b0a4 <Hacl_Impl_SHA2_256_update_last>:

static void Hacl_Impl_SHA2_256_update_last(uint32_t *state, uint8_t *data, uint32_t len)
{
    b0a4:	0b 12       	push	r11		
    b0a6:	0a 12       	push	r10		
    b0a8:	09 12       	push	r9		
    b0aa:	08 12       	push	r8		
    b0ac:	07 12       	push	r7		
    b0ae:	06 12       	push	r6		
    b0b0:	05 12       	push	r5		
    b0b2:	04 12       	push	r4		
    b0b4:	31 50 5e ff 	add	#-162,	r1	;#0xff5e
    b0b8:	81 4f 96 00 	mov	r15,	150(r1)	;0x0096(r1)
    b0bc:	0a 4e       	mov	r14,	r10	
    b0be:	81 4c 90 00 	mov	r12,	144(r1)	;0x0090(r1)
    b0c2:	81 4d 92 00 	mov	r13,	146(r1)	;0x0092(r1)
  uint8_t blocks[128U] = { 0U };
    b0c6:	3d 40 80 00 	mov	#128,	r13	;#0x0080
    b0ca:	0e 43       	clr	r14		
    b0cc:	0f 41       	mov	r1,	r15	
    b0ce:	b0 12 52 b7 	call	#0xb752	
  uint32_t nb;
  if (len < (uint32_t)56U)
    b0d2:	91 93 92 00 	cmp	#1,	146(r1)	;r3 As==01, 0x0092(r1)
    b0d6:	0e 2c       	jc	$+30     	;abs 0xb0f4
    b0d8:	b1 90 38 00 	cmp	#56,	144(r1)	;#0x0038, 0x0090(r1)
    b0dc:	90 00 
    b0de:	0a 2c       	jc	$+22     	;abs 0xb0f4
    nb = (uint32_t)1U;
    b0e0:	91 43 9c 00 	mov	#1,	156(r1)	;r3 As==01, 0x009c(r1)
    b0e4:	81 43 9e 00 	mov	#0,	158(r1)	;r3 As==00, 0x009e(r1)
  else
    nb = (uint32_t)2U;
  uint8_t *final_blocks;
  if (len < (uint32_t)56U)
    final_blocks = blocks + (uint32_t)64U;
    b0e8:	08 41       	mov	r1,	r8	
    b0ea:	38 50 40 00 	add	#64,	r8	;#0x0040
    b0ee:	81 48 94 00 	mov	r8,	148(r1)	;0x0094(r1)
    b0f2:	06 3c       	jmp	$+14     	;abs 0xb100
  uint8_t blocks[128U] = { 0U };
  uint32_t nb;
  if (len < (uint32_t)56U)
    nb = (uint32_t)1U;
  else
    nb = (uint32_t)2U;
    b0f4:	a1 43 9c 00 	mov	#2,	156(r1)	;r3 As==10, 0x009c(r1)
    b0f8:	81 43 9e 00 	mov	#0,	158(r1)	;r3 As==00, 0x009e(r1)
  uint8_t *final_blocks;
  if (len < (uint32_t)56U)
    final_blocks = blocks + (uint32_t)64U;
  else
    final_blocks = blocks;
    b0fc:	81 41 94 00 	mov	r1,	148(r1)	;0x0094(r1)
  memcpy(final_blocks, data, len * sizeof data[0U]);
    b100:	1d 41 90 00 	mov	144(r1),r13	;0x0090(r1)
    b104:	0e 4a       	mov	r10,	r14	
    b106:	1f 41 94 00 	mov	148(r1),r15	;0x0094(r1)
    b10a:	b0 12 58 b6 	call	#0xb658	
  uint32_t n1 = state[136U];
  uint8_t *padding = final_blocks + len;
    b10e:	19 41 94 00 	mov	148(r1),r9	;0x0094(r1)
    b112:	19 51 90 00 	add	144(r1),r9	;0x0090(r1)
    b116:	81 49 9a 00 	mov	r9,	154(r1)	;0x009a(r1)
  uint32_t
  pad0len = ((uint32_t)64U - (len + (uint32_t)8U + (uint32_t)1U) % (uint32_t)64U) % (uint32_t)64U;
  uint8_t *buf1 = padding;
  uint8_t *buf2 = padding + (uint32_t)1U + pad0len;
  uint64_t
  encodedlen = ((uint64_t)n1 * (uint64_t)(uint32_t)64U + (uint64_t)len) * (uint64_t)(uint32_t)8U;
    b11a:	14 41 90 00 	mov	144(r1),r4	;0x0090(r1)
    b11e:	15 41 92 00 	mov	146(r1),r5	;0x0092(r1)
    b122:	06 43       	clr	r6		
    b124:	07 43       	clr	r7		
    b126:	1b 41 96 00 	mov	150(r1),r11	;0x0096(r1)
    b12a:	1f 4b 20 02 	mov	544(r11),r15	;0x0220(r11)
    b12e:	1d 4b 22 02 	mov	546(r11),r13	;0x0222(r11)
    b132:	08 4f       	mov	r15,	r8	
    b134:	09 4d       	mov	r13,	r9	
    b136:	0a 43       	clr	r10		
    b138:	0b 43       	clr	r11		
    b13a:	08 58       	rla	r8		
    b13c:	09 69       	rlc	r9		
    b13e:	0a 6a       	rlc	r10		
    b140:	0b 6b       	rlc	r11		
    b142:	08 58       	rla	r8		
    b144:	09 69       	rlc	r9		
    b146:	0a 6a       	rlc	r10		
    b148:	0b 6b       	rlc	r11		
    b14a:	08 58       	rla	r8		
    b14c:	09 69       	rlc	r9		
    b14e:	0a 6a       	rlc	r10		
    b150:	0b 6b       	rlc	r11		
    b152:	08 58       	rla	r8		
    b154:	09 69       	rlc	r9		
    b156:	0a 6a       	rlc	r10		
    b158:	0b 6b       	rlc	r11		
    b15a:	08 58       	rla	r8		
    b15c:	09 69       	rlc	r9		
    b15e:	0a 6a       	rlc	r10		
    b160:	0b 6b       	rlc	r11		
    b162:	08 58       	rla	r8		
    b164:	09 69       	rlc	r9		
    b166:	0a 6a       	rlc	r10		
    b168:	0b 6b       	rlc	r11		
    b16a:	0c 44       	mov	r4,	r12	
    b16c:	0d 45       	mov	r5,	r13	
    b16e:	0e 46       	mov	r6,	r14	
    b170:	0f 47       	mov	r7,	r15	
    b172:	0c 58       	add	r8,	r12	
    b174:	0d 69       	addc	r9,	r13	
    b176:	0e 6a       	addc	r10,	r14	
    b178:	0f 6b       	addc	r11,	r15	
    b17a:	0c 5c       	rla	r12		
    b17c:	0d 6d       	rlc	r13		
    b17e:	0e 6e       	rlc	r14		
    b180:	0f 6f       	rlc	r15		
    b182:	0c 5c       	rla	r12		
    b184:	0d 6d       	rlc	r13		
    b186:	0e 6e       	rlc	r14		
    b188:	0f 6f       	rlc	r15		
    b18a:	0c 5c       	rla	r12		
    b18c:	0d 6d       	rlc	r13		
    b18e:	0e 6e       	rlc	r14		
    b190:	0f 6f       	rlc	r15		
  buf1[0U] = (uint8_t)0x80U;
    b192:	18 41 9a 00 	mov	154(r1),r8	;0x009a(r1)
    b196:	f8 40 80 ff 	mov.b	#-128,	0(r8)	;#0xff80, 0x0000(r8)
    b19a:	00 00 
  store64_be(buf2, encodedlen);
    b19c:	81 4c a0 00 	mov	r12,	160(r1)	;0x00a0(r1)
    b1a0:	81 4d 98 00 	mov	r13,	152(r1)	;0x0098(r1)
    b1a4:	48 4e       	mov.b	r14,	r8	
    b1a6:	06 43       	clr	r6		
    b1a8:	07 43       	clr	r7		
    b1aa:	07 48       	mov	r8,	r7	
    b1ac:	87 10       	swpb	r7		
    b1ae:	04 4f       	mov	r15,	r4	
    b1b0:	84 10       	swpb	r4		
    b1b2:	4a 44       	mov.b	r4,	r10	
    b1b4:	0b 43       	clr	r11		
    b1b6:	0a d6       	bis	r6,	r10	
    b1b8:	0b d7       	bis	r7,	r11	
    b1ba:	04 4e       	mov	r14,	r4	
    b1bc:	05 4f       	mov	r15,	r5	
    b1be:	84 10       	swpb	r4		
    b1c0:	85 10       	swpb	r5		
    b1c2:	44 e5       	xor.b	r5,	r4	
    b1c4:	04 e5       	xor	r5,	r4	
    b1c6:	45 45       	mov.b	r5,	r5	
    b1c8:	06 44       	mov	r4,	r6	
    b1ca:	07 45       	mov	r5,	r7	
    b1cc:	36 f0 00 ff 	and	#-256,	r6	;#0xff00
    b1d0:	07 f3       	and	#0,	r7	;r3 As==00
    b1d2:	06 da       	bis	r10,	r6	
    b1d4:	07 db       	bis	r11,	r7	
    b1d6:	0b 4f       	mov	r15,	r11	
    b1d8:	4b ee       	xor.b	r14,	r11	
    b1da:	0b ee       	xor	r14,	r11	
    b1dc:	8b 10       	swpb	r11		
    b1de:	4a 4e       	mov.b	r14,	r10	
    b1e0:	8a 10       	swpb	r10		
    b1e2:	0a f3       	and	#0,	r10	;r3 As==00
    b1e4:	3b f0 ff 00 	and	#255,	r11	;#0x00ff
    b1e8:	08 46       	mov	r6,	r8	
    b1ea:	09 47       	mov	r7,	r9	
    b1ec:	08 da       	bis	r10,	r8	
    b1ee:	09 db       	bis	r11,	r9	
    b1f0:	81 48 88 00 	mov	r8,	136(r1)	;0x0088(r1)
    b1f4:	81 49 8a 00 	mov	r9,	138(r1)	;0x008a(r1)
    b1f8:	81 43 8c 00 	mov	#0,	140(r1)	;r3 As==00, 0x008c(r1)
    b1fc:	81 43 8e 00 	mov	#0,	142(r1)	;r3 As==00, 0x008e(r1)
    b200:	58 41 a0 00 	mov.b	160(r1),r8	;0x00a0(r1)
    b204:	06 43       	clr	r6		
    b206:	07 43       	clr	r7		
    b208:	07 48       	mov	r8,	r7	
    b20a:	87 10       	swpb	r7		
    b20c:	08 4d       	mov	r13,	r8	
    b20e:	88 10       	swpb	r8		
    b210:	4a 48       	mov.b	r8,	r10	
    b212:	0b 43       	clr	r11		
    b214:	0a d6       	bis	r6,	r10	
    b216:	0b d7       	bis	r7,	r11	
    b218:	04 4c       	mov	r12,	r4	
    b21a:	05 4d       	mov	r13,	r5	
    b21c:	84 10       	swpb	r4		
    b21e:	85 10       	swpb	r5		
    b220:	44 e5       	xor.b	r5,	r4	
    b222:	04 e5       	xor	r5,	r4	
    b224:	45 45       	mov.b	r5,	r5	
    b226:	06 44       	mov	r4,	r6	
    b228:	07 45       	mov	r5,	r7	
    b22a:	36 f0 00 ff 	and	#-256,	r6	;#0xff00
    b22e:	07 f3       	and	#0,	r7	;r3 As==00
    b230:	06 da       	bis	r10,	r6	
    b232:	07 db       	bis	r11,	r7	
    b234:	0b 4d       	mov	r13,	r11	
    b236:	4b ec       	xor.b	r12,	r11	
    b238:	0b ec       	xor	r12,	r11	
    b23a:	8b 10       	swpb	r11		
    b23c:	4a 4c       	mov.b	r12,	r10	
    b23e:	8a 10       	swpb	r10		
    b240:	08 4a       	mov	r10,	r8	
    b242:	09 4b       	mov	r11,	r9	
    b244:	08 f3       	and	#0,	r8	;r3 As==00
    b246:	39 f0 ff 00 	and	#255,	r9	;#0x00ff
    b24a:	06 d8       	bis	r8,	r6	
    b24c:	07 d9       	bis	r9,	r7	
    b24e:	08 43       	clr	r8		
    b250:	09 43       	clr	r9		
    b252:	0a 43       	clr	r10		
    b254:	0b 43       	clr	r11		
    b256:	09 43       	clr	r9		
    b258:	0a 46       	mov	r6,	r10	
    b25a:	0b 47       	mov	r7,	r11	
    b25c:	1c 41 88 00 	mov	136(r1),r12	;0x0088(r1)
    b260:	1d 41 8a 00 	mov	138(r1),r13	;0x008a(r1)
    b264:	1e 41 8c 00 	mov	140(r1),r14	;0x008c(r1)
    b268:	1f 41 8e 00 	mov	142(r1),r15	;0x008e(r1)
    b26c:	0c d8       	bis	r8,	r12	
    b26e:	0d d9       	bis	r9,	r13	
    b270:	0e da       	bis	r10,	r14	
    b272:	0f db       	bis	r11,	r15	
    b274:	81 4c 80 00 	mov	r12,	128(r1)	;0x0080(r1)
    b278:	81 4d 82 00 	mov	r13,	130(r1)	;0x0082(r1)
    b27c:	81 4e 84 00 	mov	r14,	132(r1)	;0x0084(r1)
    b280:	81 4f 86 00 	mov	r15,	134(r1)	;0x0086(r1)
    final_blocks = blocks;
  memcpy(final_blocks, data, len * sizeof data[0U]);
  uint32_t n1 = state[136U];
  uint8_t *padding = final_blocks + len;
  uint32_t
  pad0len = ((uint32_t)64U - (len + (uint32_t)8U + (uint32_t)1U) % (uint32_t)64U) % (uint32_t)64U;
    b284:	3a 40 f7 ff 	mov	#-9,	r10	;#0xfff7
    b288:	3b 43       	mov	#-1,	r11	;r3 As==11
    b28a:	1a 81 90 00 	sub	144(r1),r10	;0x0090(r1)
    b28e:	1b 71 92 00 	subc	146(r1),r11	;0x0092(r1)
    b292:	3a f0 3f 00 	and	#63,	r10	;#0x003f
    b296:	0b f3       	and	#0,	r11	;r3 As==00
  uint8_t *buf1 = padding;
  uint8_t *buf2 = padding + (uint32_t)1U + pad0len;
    b298:	1a 53       	inc	r10		
    b29a:	1d 41 9a 00 	mov	154(r1),r13	;0x009a(r1)
    b29e:	0d 5a       	add	r10,	r13	

inline static void store16(uint8_t *b, uint16_t i) { memcpy(b, &i, 2); }

inline static void store32(uint8_t *b, uint32_t i) { memcpy(b, &i, 4); }

inline static void store64(uint8_t *b, uint64_t i) { memcpy(b, &i, 8); }
    b2a0:	dd 41 80 00 	mov.b	128(r1),0(r13)	;0x0080(r1), 0x0000(r13)
    b2a4:	00 00 
    b2a6:	1d 53       	inc	r13		
    b2a8:	dd 41 81 00 	mov.b	129(r1),0(r13)	;0x0081(r1), 0x0000(r13)
    b2ac:	00 00 
    b2ae:	1d 53       	inc	r13		
    b2b0:	dd 41 82 00 	mov.b	130(r1),0(r13)	;0x0082(r1), 0x0000(r13)
    b2b4:	00 00 
    b2b6:	1d 53       	inc	r13		
    b2b8:	dd 41 83 00 	mov.b	131(r1),0(r13)	;0x0083(r1), 0x0000(r13)
    b2bc:	00 00 
    b2be:	1d 53       	inc	r13		
    b2c0:	dd 41 84 00 	mov.b	132(r1),0(r13)	;0x0084(r1), 0x0000(r13)
    b2c4:	00 00 
    b2c6:	1d 53       	inc	r13		
    b2c8:	dd 41 85 00 	mov.b	133(r1),0(r13)	;0x0085(r1), 0x0000(r13)
    b2cc:	00 00 
    b2ce:	1d 53       	inc	r13		
    b2d0:	dd 41 86 00 	mov.b	134(r1),0(r13)	;0x0086(r1), 0x0000(r13)
    b2d4:	00 00 
    b2d6:	dd 41 87 00 	mov.b	135(r1),1(r13)	;0x0087(r1), 0x0001(r13)
    b2da:	01 00 
  uint64_t
  encodedlen = ((uint64_t)n1 * (uint64_t)(uint32_t)64U + (uint64_t)len) * (uint64_t)(uint32_t)8U;
  buf1[0U] = (uint8_t)0x80U;
  store64_be(buf2, encodedlen);
  Hacl_Impl_SHA2_256_update_multi(state, final_blocks, nb);
    b2dc:	1c 41 9c 00 	mov	156(r1),r12	;0x009c(r1)
    b2e0:	1d 41 9e 00 	mov	158(r1),r13	;0x009e(r1)
    b2e4:	1e 41 94 00 	mov	148(r1),r14	;0x0094(r1)
    b2e8:	1f 41 96 00 	mov	150(r1),r15	;0x0096(r1)
    b2ec:	b0 12 5e b0 	call	#0xb05e	
}
    b2f0:	31 50 a2 00 	add	#162,	r1	;#0x00a2
    b2f4:	34 41       	pop	r4		
    b2f6:	35 41       	pop	r5		
    b2f8:	36 41       	pop	r6		
    b2fa:	37 41       	pop	r7		
    b2fc:	38 41       	pop	r8		
    b2fe:	39 41       	pop	r9		
    b300:	3a 41       	pop	r10		
    b302:	3b 41       	pop	r11		
    b304:	30 41       	ret			

0000b306 <Hacl_Impl_SHA2_256_finish>:

static void Hacl_Impl_SHA2_256_finish(uint32_t *state, uint8_t *hash1)
{
    b306:	0b 12       	push	r11		
    b308:	0a 12       	push	r10		
    b30a:	09 12       	push	r9		
    b30c:	08 12       	push	r8		
    b30e:	07 12       	push	r7		
    b310:	06 12       	push	r6		
    b312:	05 12       	push	r5		
    b314:	04 12       	push	r4		
    b316:	31 50 f0 ff 	add	#-16,	r1	;#0xfff0
  uint32_t *hash_w = state + (uint32_t)128U;
    b31a:	06 4f       	mov	r15,	r6	
    b31c:	36 50 00 02 	add	#512,	r6	;#0x0200
  buf1[0U] = (uint8_t)0x80U;
  store64_be(buf2, encodedlen);
  Hacl_Impl_SHA2_256_update_multi(state, final_blocks, nb);
}

static void Hacl_Impl_SHA2_256_finish(uint32_t *state, uint8_t *hash1)
    b320:	0d 4f       	mov	r15,	r13	
    b322:	3d 50 20 02 	add	#544,	r13	;#0x0220
    b326:	81 4d 08 00 	mov	r13,	8(r1)	;0x0008(r1)
    b32a:	0e 8f       	sub	r15,	r14	
    b32c:	3e 50 00 fe 	add	#-512,	r14	;#0xfe00
    b330:	81 4e 0a 00 	mov	r14,	10(r1)	;0x000a(r1)
  return x;
}

inline static void store16(uint8_t *b, uint16_t i) { memcpy(b, &i, 2); }

inline static void store32(uint8_t *b, uint32_t i) { memcpy(b, &i, 4); }
    b334:	1e 43       	mov	#1,	r14	;r3 As==01
    b336:	0e 51       	add	r1,	r14	
    b338:	1e 53       	inc	r14		
    b33a:	0f 4e       	mov	r14,	r15	
    b33c:	1f 53       	inc	r15		
    b33e:	81 4f 0c 00 	mov	r15,	12(r1)	;0x000c(r1)
    b342:	81 4e 0e 00 	mov	r14,	14(r1)	;0x000e(r1)
static void
Hacl_Hash_Lib_LoadStore_uint32s_to_be_bytes(uint8_t *output, uint32_t *input, uint32_t len)
{
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
  {
    uint32_t hd1 = input[i];
    b346:	2e 46       	mov	@r6,	r14	
    b348:	17 46 02 00 	mov	2(r6),	r7	;0x0002(r6)
    uint8_t *x0 = output + (uint32_t)4U * i;
    store32_be(x0, hd1);
    b34c:	4f 4e       	mov.b	r14,	r15	
    b34e:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00, 0x0004(r1)
    b352:	8f 10       	swpb	r15		
    b354:	81 4f 06 00 	mov	r15,	6(r1)	;0x0006(r1)
    b358:	0f 47       	mov	r7,	r15	
    b35a:	8f 10       	swpb	r15		
    b35c:	44 4f       	mov.b	r15,	r4	
    b35e:	05 43       	clr	r5		
    b360:	18 41 04 00 	mov	4(r1),	r8	;0x0004(r1)
    b364:	19 41 06 00 	mov	6(r1),	r9	;0x0006(r1)
    b368:	08 d4       	bis	r4,	r8	
    b36a:	09 d5       	bis	r5,	r9	
    b36c:	0c 4e       	mov	r14,	r12	
    b36e:	0d 47       	mov	r7,	r13	
    b370:	8c 10       	swpb	r12		
    b372:	8d 10       	swpb	r13		
    b374:	4c ed       	xor.b	r13,	r12	
    b376:	0c ed       	xor	r13,	r12	
    b378:	4d 4d       	mov.b	r13,	r13	
    b37a:	3c f0 00 ff 	and	#-256,	r12	;#0xff00
    b37e:	0d f3       	and	#0,	r13	;r3 As==00
    b380:	08 dc       	bis	r12,	r8	
    b382:	09 dd       	bis	r13,	r9	
    b384:	0b 47       	mov	r7,	r11	
    b386:	4b ee       	xor.b	r14,	r11	
    b388:	0b ee       	xor	r14,	r11	
    b38a:	8b 10       	swpb	r11		
    b38c:	4a 4e       	mov.b	r14,	r10	
    b38e:	8a 10       	swpb	r10		
    b390:	0c 4a       	mov	r10,	r12	
    b392:	0d 4b       	mov	r11,	r13	
    b394:	0c f3       	and	#0,	r12	;r3 As==00
    b396:	3d f0 ff 00 	and	#255,	r13	;#0x00ff
    b39a:	0e 48       	mov	r8,	r14	
    b39c:	0f 49       	mov	r9,	r15	
    b39e:	0e dc       	bis	r12,	r14	
    b3a0:	0f dd       	bis	r13,	r15	
    b3a2:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    b3a6:	81 4f 02 00 	mov	r15,	2(r1)	;0x0002(r1)
  buf1[0U] = (uint8_t)0x80U;
  store64_be(buf2, encodedlen);
  Hacl_Impl_SHA2_256_update_multi(state, final_blocks, nb);
}

static void Hacl_Impl_SHA2_256_finish(uint32_t *state, uint8_t *hash1)
    b3aa:	1f 41 0a 00 	mov	10(r1),	r15	;0x000a(r1)
    b3ae:	0f 56       	add	r6,	r15	
    b3b0:	ef 41 00 00 	mov.b	@r1,	0(r15)	;0x0000(r15)
    b3b4:	1f 53       	inc	r15		
    b3b6:	df 41 01 00 	mov.b	1(r1),	0(r15)	;0x0001(r1), 0x0000(r15)
    b3ba:	00 00 
    b3bc:	1f 53       	inc	r15		
    b3be:	1d 41 0e 00 	mov	14(r1),	r13	;0x000e(r1)
    b3c2:	ef 4d 00 00 	mov.b	@r13,	0(r15)	;0x0000(r15)
    b3c6:	1e 41 0c 00 	mov	12(r1),	r14	;0x000c(r1)
    b3ca:	ef 4e 01 00 	mov.b	@r14,	1(r15)	;0x0001(r15)
    b3ce:	26 52       	add	#4,	r6	;r2 As==10
}

static void
Hacl_Hash_Lib_LoadStore_uint32s_to_be_bytes(uint8_t *output, uint32_t *input, uint32_t len)
{
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
    b3d0:	16 91 08 00 	cmp	8(r1),	r6	;0x0008(r1)
    b3d4:	b8 23       	jnz	$-142    	;abs 0xb346

static void Hacl_Impl_SHA2_256_finish(uint32_t *state, uint8_t *hash1)
{
  uint32_t *hash_w = state + (uint32_t)128U;
  Hacl_Hash_Lib_LoadStore_uint32s_to_be_bytes(hash1, hash_w, (uint32_t)8U);
}
    b3d6:	31 50 10 00 	add	#16,	r1	;#0x0010
    b3da:	34 41       	pop	r4		
    b3dc:	35 41       	pop	r5		
    b3de:	36 41       	pop	r6		
    b3e0:	37 41       	pop	r7		
    b3e2:	38 41       	pop	r8		
    b3e4:	39 41       	pop	r9		
    b3e6:	3a 41       	pop	r10		
    b3e8:	3b 41       	pop	r11		
    b3ea:	30 41       	ret			

0000b3ec <Hacl_Impl_SHA2_256_hash>:

static void Hacl_Impl_SHA2_256_hash(uint8_t *hash1, uint8_t *input, uint32_t len)
{
    b3ec:	0b 12       	push	r11		
    b3ee:	0a 12       	push	r10		
    b3f0:	09 12       	push	r9		
    b3f2:	08 12       	push	r8		
    b3f4:	07 12       	push	r7		
    b3f6:	06 12       	push	r6		
    b3f8:	05 12       	push	r5		
    b3fa:	31 50 dc fd 	add	#-548,	r1	;#0xfddc
    b3fe:	06 4f       	mov	r15,	r6	
    b400:	07 4e       	mov	r14,	r7	
    b402:	08 4c       	mov	r12,	r8	
    b404:	09 4d       	mov	r13,	r9	
  uint32_t state[137U] = { 0U };
    b406:	3d 40 24 02 	mov	#548,	r13	;#0x0224
    b40a:	0e 43       	clr	r14		
    b40c:	0f 41       	mov	r1,	r15	
    b40e:	b0 12 52 b7 	call	#0xb752	
  uint32_t n1 = len / (uint32_t)64U;
    b412:	0a 48       	mov	r8,	r10	
    b414:	0b 49       	mov	r9,	r11	
    b416:	12 c3       	clrc			
    b418:	0b 10       	rrc	r11		
    b41a:	0a 10       	rrc	r10		
    b41c:	12 c3       	clrc			
    b41e:	0b 10       	rrc	r11		
    b420:	0a 10       	rrc	r10		
    b422:	12 c3       	clrc			
    b424:	0b 10       	rrc	r11		
    b426:	0a 10       	rrc	r10		
    b428:	12 c3       	clrc			
    b42a:	0b 10       	rrc	r11		
    b42c:	0a 10       	rrc	r10		
    b42e:	12 c3       	clrc			
    b430:	0b 10       	rrc	r11		
    b432:	0a 10       	rrc	r10		
    b434:	12 c3       	clrc			
    b436:	0b 10       	rrc	r11		
    b438:	0a 10       	rrc	r10		
  uint32_t r = len % (uint32_t)64U;
  uint8_t *input_blocks = input;
  uint8_t *input_last = input + n1 * (uint32_t)64U;
    b43a:	0d 4a       	mov	r10,	r13	
    b43c:	0d 5d       	rla	r13		
    b43e:	0d 5d       	rla	r13		
    b440:	0d 5d       	rla	r13		
    b442:	0d 5d       	rla	r13		
    b444:	0d 5d       	rla	r13		
    b446:	0d 5d       	rla	r13		
    b448:	05 47       	mov	r7,	r5	
    b44a:	05 5d       	add	r13,	r5	
  Hacl_Impl_SHA2_256_init(state);
    b44c:	0f 41       	mov	r1,	r15	
    b44e:	b0 12 a0 a6 	call	#0xa6a0	
  Hacl_Impl_SHA2_256_update_multi(state, input_blocks, n1);
    b452:	0c 4a       	mov	r10,	r12	
    b454:	0d 4b       	mov	r11,	r13	
    b456:	0e 47       	mov	r7,	r14	
    b458:	0f 41       	mov	r1,	r15	
    b45a:	b0 12 5e b0 	call	#0xb05e	
  Hacl_Impl_SHA2_256_update_last(state, input_last, r);
    b45e:	0c 48       	mov	r8,	r12	
    b460:	0d 49       	mov	r9,	r13	
    b462:	3c f0 3f 00 	and	#63,	r12	;#0x003f
    b466:	0d f3       	and	#0,	r13	;r3 As==00
    b468:	0e 45       	mov	r5,	r14	
    b46a:	0f 41       	mov	r1,	r15	
    b46c:	b0 12 a4 b0 	call	#0xb0a4	
  Hacl_Impl_SHA2_256_finish(state, hash1);
    b470:	0e 46       	mov	r6,	r14	
    b472:	0f 41       	mov	r1,	r15	
    b474:	b0 12 06 b3 	call	#0xb306	
}
    b478:	31 50 24 02 	add	#548,	r1	;#0x0224
    b47c:	35 41       	pop	r5		
    b47e:	36 41       	pop	r6		
    b480:	37 41       	pop	r7		
    b482:	38 41       	pop	r8		
    b484:	39 41       	pop	r9		
    b486:	3a 41       	pop	r10		
    b488:	3b 41       	pop	r11		
    b48a:	30 41       	ret			

0000b48c <Hacl_Impl_HMAC_SHA2_256_hmac_core>:
  }
}

static void
Hacl_Impl_HMAC_SHA2_256_hmac_core(uint8_t *mac, uint8_t *key, uint8_t *data, uint32_t len)
{
    b48c:	0b 12       	push	r11		
    b48e:	0a 12       	push	r10		
    b490:	09 12       	push	r9		
    b492:	08 12       	push	r8		
    b494:	07 12       	push	r7		
    b496:	06 12       	push	r6		
    b498:	05 12       	push	r5		
    b49a:	04 12       	push	r4		
    b49c:	31 50 38 fb 	add	#-1224,	r1	;#0xfb38
    b4a0:	04 4f       	mov	r15,	r4	
    b4a2:	08 4e       	mov	r14,	r8	
    b4a4:	05 4d       	mov	r13,	r5	
    b4a6:	16 41 da 04 	mov	1242(r1),r6	;0x04da(r1)
    b4aa:	17 41 dc 04 	mov	1244(r1),r7	;0x04dc(r1)
    b4ae:	0b 41       	mov	r1,	r11	
    a[i] = xi ^ yi;
  }
}

static void
Hacl_Impl_HMAC_SHA2_256_hmac_core(uint8_t *mac, uint8_t *key, uint8_t *data, uint32_t len)
    b4b0:	0a 41       	mov	r1,	r10	
    b4b2:	3a 50 40 00 	add	#64,	r10	;#0x0040
{
  uint8_t ipad[64U];
  for (uint32_t _i = 0U; _i < (uint32_t)64U; ++_i)
    ipad[_i] = (uint8_t)0x36U;
    b4b6:	fb 40 36 00 	mov.b	#54,	0(r11)	;#0x0036, 0x0000(r11)
    b4ba:	00 00 
    b4bc:	1b 53       	inc	r11		

static void
Hacl_Impl_HMAC_SHA2_256_hmac_core(uint8_t *mac, uint8_t *key, uint8_t *data, uint32_t len)
{
  uint8_t ipad[64U];
  for (uint32_t _i = 0U; _i < (uint32_t)64U; ++_i)
    b4be:	0b 9a       	cmp	r10,	r11	
    b4c0:	fa 23       	jnz	$-10     	;abs 0xb4b6
    b4c2:	0b 41       	mov	r1,	r11	
    b4c4:	3b 50 40 00 	add	#64,	r11	;#0x0040
    a[i] = xi ^ yi;
  }
}

static void
Hacl_Impl_HMAC_SHA2_256_hmac_core(uint8_t *mac, uint8_t *key, uint8_t *data, uint32_t len)
    b4c8:	0a 4b       	mov	r11,	r10	
    b4ca:	3a 50 40 00 	add	#64,	r10	;#0x0040
  uint8_t ipad[64U];
  for (uint32_t _i = 0U; _i < (uint32_t)64U; ++_i)
    ipad[_i] = (uint8_t)0x36U;
  uint8_t opad[64U];
  for (uint32_t _i = 0U; _i < (uint32_t)64U; ++_i)
    opad[_i] = (uint8_t)0x5cU;
    b4ce:	fb 40 5c 00 	mov.b	#92,	0(r11)	;#0x005c, 0x0000(r11)
    b4d2:	00 00 
    b4d4:	1b 53       	inc	r11		
{
  uint8_t ipad[64U];
  for (uint32_t _i = 0U; _i < (uint32_t)64U; ++_i)
    ipad[_i] = (uint8_t)0x36U;
  uint8_t opad[64U];
  for (uint32_t _i = 0U; _i < (uint32_t)64U; ++_i)
    b4d6:	0b 9a       	cmp	r10,	r11	
    b4d8:	fa 23       	jnz	$-10     	;abs 0xb4ce
    opad[_i] = (uint8_t)0x5cU;
  Hacl_Impl_HMAC_SHA2_256_xor_bytes_inplace(ipad, key, (uint32_t)64U);
    b4da:	3c 40 40 00 	mov	#64,	r12	;#0x0040
    b4de:	0d 43       	clr	r13		
    b4e0:	0e 48       	mov	r8,	r14	
    b4e2:	0f 41       	mov	r1,	r15	
    b4e4:	b0 12 02 aa 	call	#0xaa02	
  uint32_t state0[137U] = { 0U };
    b4e8:	3d 40 24 02 	mov	#548,	r13	;#0x0224
    b4ec:	0e 43       	clr	r14		
    b4ee:	0f 41       	mov	r1,	r15	
    b4f0:	3f 50 80 00 	add	#128,	r15	;#0x0080
    b4f4:	b0 12 52 b7 	call	#0xb752	
  uint32_t n0 = len / (uint32_t)64U;
    b4f8:	0a 46       	mov	r6,	r10	
    b4fa:	0b 47       	mov	r7,	r11	
    b4fc:	12 c3       	clrc			
    b4fe:	0b 10       	rrc	r11		
    b500:	0a 10       	rrc	r10		
    b502:	12 c3       	clrc			
    b504:	0b 10       	rrc	r11		
    b506:	0a 10       	rrc	r10		
    b508:	12 c3       	clrc			
    b50a:	0b 10       	rrc	r11		
    b50c:	0a 10       	rrc	r10		
    b50e:	12 c3       	clrc			
    b510:	0b 10       	rrc	r11		
    b512:	0a 10       	rrc	r10		
    b514:	12 c3       	clrc			
    b516:	0b 10       	rrc	r11		
    b518:	0a 10       	rrc	r10		
    b51a:	12 c3       	clrc			
    b51c:	0b 10       	rrc	r11		
    b51e:	0a 10       	rrc	r10		
  uint32_t r0 = len % (uint32_t)64U;
  uint8_t *blocks0 = data;
  uint8_t *last0 = data + n0 * (uint32_t)64U;
    b520:	09 4a       	mov	r10,	r9	
    b522:	09 59       	rla	r9		
    b524:	09 59       	rla	r9		
    b526:	09 59       	rla	r9		
    b528:	09 59       	rla	r9		
    b52a:	09 59       	rla	r9		
    b52c:	09 59       	rla	r9		
    b52e:	09 55       	add	r5,	r9	
  Hacl_Impl_SHA2_256_init(state0);
    b530:	0f 41       	mov	r1,	r15	
    b532:	3f 50 80 00 	add	#128,	r15	;#0x0080
    b536:	b0 12 a0 a6 	call	#0xa6a0	
  Hacl_Impl_SHA2_256_update(state0, ipad);
    b53a:	0e 41       	mov	r1,	r14	
    b53c:	0f 41       	mov	r1,	r15	
    b53e:	3f 50 80 00 	add	#128,	r15	;#0x0080
    b542:	b0 12 2a aa 	call	#0xaa2a	
  Hacl_Impl_SHA2_256_update_multi(state0, blocks0, n0);
    b546:	0c 4a       	mov	r10,	r12	
    b548:	0d 4b       	mov	r11,	r13	
    b54a:	0e 45       	mov	r5,	r14	
    b54c:	0f 41       	mov	r1,	r15	
    b54e:	3f 50 80 00 	add	#128,	r15	;#0x0080
    b552:	b0 12 5e b0 	call	#0xb05e	
  Hacl_Impl_SHA2_256_update_last(state0, last0, r0);
    b556:	0c 46       	mov	r6,	r12	
    b558:	0d 47       	mov	r7,	r13	
    b55a:	3c f0 3f 00 	and	#63,	r12	;#0x003f
    b55e:	0d f3       	and	#0,	r13	;r3 As==00
    b560:	0e 49       	mov	r9,	r14	
    b562:	0f 41       	mov	r1,	r15	
    b564:	3f 50 80 00 	add	#128,	r15	;#0x0080
    b568:	b0 12 a4 b0 	call	#0xb0a4	
  uint8_t *hash0 = ipad;
  Hacl_Impl_SHA2_256_finish(state0, hash0);
    b56c:	0e 41       	mov	r1,	r14	
    b56e:	0f 41       	mov	r1,	r15	
    b570:	3f 50 80 00 	add	#128,	r15	;#0x0080
    b574:	b0 12 06 b3 	call	#0xb306	
  uint8_t *s4 = ipad;
  Hacl_Impl_HMAC_SHA2_256_xor_bytes_inplace(opad, key, (uint32_t)64U);
    b578:	3c 40 40 00 	mov	#64,	r12	;#0x0040
    b57c:	0d 43       	clr	r13		
    b57e:	0e 48       	mov	r8,	r14	
    b580:	0f 41       	mov	r1,	r15	
    b582:	3f 50 40 00 	add	#64,	r15	;#0x0040
    b586:	b0 12 02 aa 	call	#0xaa02	
  uint32_t state1[137U] = { 0U };
    b58a:	3d 40 24 02 	mov	#548,	r13	;#0x0224
    b58e:	0e 43       	clr	r14		
    b590:	0f 41       	mov	r1,	r15	
    b592:	3f 50 a4 02 	add	#676,	r15	;#0x02a4
    b596:	b0 12 52 b7 	call	#0xb752	
  Hacl_Impl_SHA2_256_init(state1);
    b59a:	0f 41       	mov	r1,	r15	
    b59c:	3f 50 a4 02 	add	#676,	r15	;#0x02a4
    b5a0:	b0 12 a0 a6 	call	#0xa6a0	
  Hacl_Impl_SHA2_256_update(state1, opad);
    b5a4:	0e 41       	mov	r1,	r14	
    b5a6:	3e 50 40 00 	add	#64,	r14	;#0x0040
    b5aa:	0f 41       	mov	r1,	r15	
    b5ac:	3f 50 a4 02 	add	#676,	r15	;#0x02a4
    b5b0:	b0 12 2a aa 	call	#0xaa2a	
  Hacl_Impl_SHA2_256_update_last(state1, s4, (uint32_t)32U);
    b5b4:	3c 40 20 00 	mov	#32,	r12	;#0x0020
    b5b8:	0d 43       	clr	r13		
    b5ba:	0e 41       	mov	r1,	r14	
    b5bc:	0f 41       	mov	r1,	r15	
    b5be:	3f 50 a4 02 	add	#676,	r15	;#0x02a4
    b5c2:	b0 12 a4 b0 	call	#0xb0a4	
  Hacl_Impl_SHA2_256_finish(state1, mac);
    b5c6:	0e 44       	mov	r4,	r14	
    b5c8:	0f 41       	mov	r1,	r15	
    b5ca:	3f 50 a4 02 	add	#676,	r15	;#0x02a4
    b5ce:	b0 12 06 b3 	call	#0xb306	
}
    b5d2:	31 50 c8 04 	add	#1224,	r1	;#0x04c8
    b5d6:	34 41       	pop	r4		
    b5d8:	35 41       	pop	r5		
    b5da:	36 41       	pop	r6		
    b5dc:	37 41       	pop	r7		
    b5de:	38 41       	pop	r8		
    b5e0:	39 41       	pop	r9		
    b5e2:	3a 41       	pop	r10		
    b5e4:	3b 41       	pop	r11		
    b5e6:	30 41       	ret			

0000b5e8 <hash>:
  Hacl_Impl_HMAC_SHA2_256_hmac_core(mac, nkey, data, datalen);
}

void hash(uint8_t *hash1, uint8_t *input, uint32_t len)
{
  Hacl_Impl_SHA2_256_hash(hash1, input,  len);
    b5e8:	b0 12 ec b3 	call	#0xb3ec	
}
    b5ec:	30 41       	ret			

0000b5ee <hmac_core>:

void hmac_core(uint8_t *mac, uint8_t *key, uint8_t *data, uint32_t len)
{
  Hacl_Impl_HMAC_SHA2_256_hmac_core(mac, key, data, len);
    b5ee:	11 12 06 00 	push	6(r1)		;0x0006(r1)
    b5f2:	11 12 06 00 	push	6(r1)		;0x0006(r1)
    b5f6:	b0 12 8c b4 	call	#0xb48c	
    b5fa:	21 52       	add	#4,	r1	;r2 As==10
}
    b5fc:	30 41       	ret			

0000b5fe <hmac>:

void hmac(uint8_t *mac, uint8_t *key, uint32_t keylen, uint8_t *data, uint32_t datalen)
{
    b5fe:	0b 12       	push	r11		
    b600:	0a 12       	push	r10		
    b602:	09 12       	push	r9		
    b604:	31 50 c0 ff 	add	#-64,	r1	;#0xffc0
    b608:	09 4f       	mov	r15,	r9	
    b60a:	0b 41       	mov	r1,	r11	
void hmac_core(uint8_t *mac, uint8_t *key, uint8_t *data, uint32_t len)
{
  Hacl_Impl_HMAC_SHA2_256_hmac_core(mac, key, data, len);
}

void hmac(uint8_t *mac, uint8_t *key, uint32_t keylen, uint8_t *data, uint32_t datalen)
    b60c:	0a 41       	mov	r1,	r10	
    b60e:	3a 50 40 00 	add	#64,	r10	;#0x0040
  uint32_t datalen
)
{
  uint8_t nkey[64U];
  for (uint32_t _i = 0U; _i < (uint32_t)64U; ++_i)
    nkey[_i] = (uint8_t)0x00U;
    b612:	cb 43 00 00 	mov.b	#0,	0(r11)	;r3 As==00, 0x0000(r11)
    b616:	1b 53       	inc	r11		
  uint8_t *data,
  uint32_t datalen
)
{
  uint8_t nkey[64U];
  for (uint32_t _i = 0U; _i < (uint32_t)64U; ++_i)
    b618:	0b 9a       	cmp	r10,	r11	
    b61a:	fb 23       	jnz	$-8      	;abs 0xb612
    nkey[_i] = (uint8_t)0x00U;
  if (keylen <= (uint32_t)64U)
    b61c:	1d 93       	cmp	#1,	r13	;r3 As==01
    b61e:	08 2c       	jc	$+18     	;abs 0xb630
    b620:	3c 90 41 00 	cmp	#65,	r12	;#0x0041
    b624:	05 2c       	jc	$+12     	;abs 0xb630
    memcpy(nkey, key, keylen * sizeof key[0U]);
    b626:	0d 4c       	mov	r12,	r13	
    b628:	0f 41       	mov	r1,	r15	
    b62a:	b0 12 58 b6 	call	#0xb658	
    b62e:	03 3c       	jmp	$+8      	;abs 0xb636
  else
  {
    uint8_t *nkey0 = nkey;
    Hacl_Impl_SHA2_256_hash(nkey0, key, keylen);
    b630:	0f 41       	mov	r1,	r15	
    b632:	b0 12 ec b3 	call	#0xb3ec	
  }
  Hacl_Impl_HMAC_SHA2_256_hmac_core(mac, nkey, data, datalen);
    b636:	11 12 4e 00 	push	78(r1)		;0x004e(r1)
    b63a:	11 12 4e 00 	push	78(r1)		;0x004e(r1)
    b63e:	1d 41 4c 00 	mov	76(r1),	r13	;0x004c(r1)
    b642:	0e 41       	mov	r1,	r14	
    b644:	2e 52       	add	#4,	r14	;r2 As==10
    b646:	0f 49       	mov	r9,	r15	
    b648:	b0 12 8c b4 	call	#0xb48c	
}

void hmac(uint8_t *mac, uint8_t *key, uint32_t keylen, uint8_t *data, uint32_t datalen)
{
  Hacl_Impl_HMAC_SHA2_256_hmac(mac, key, keylen, data, datalen);
}
    b64c:	31 50 44 00 	add	#68,	r1	;#0x0044
    b650:	39 41       	pop	r9		
    b652:	3a 41       	pop	r10		
    b654:	3b 41       	pop	r11		
    b656:	30 41       	ret			

0000b658 <memcpy>:
    b658:	0b 12       	push	r11		
    b65a:	0a 12       	push	r10		
    b65c:	09 12       	push	r9		
    b65e:	08 12       	push	r8		
    b660:	07 12       	push	r7		
    b662:	0d 93       	tst	r13		
    b664:	70 24       	jz	$+226    	;abs 0xb746
    b666:	0f 9e       	cmp	r14,	r15	
    b668:	6e 24       	jz	$+222    	;abs 0xb746
    b66a:	34 2c       	jc	$+106    	;abs 0xb6d4
    b66c:	0c 4e       	mov	r14,	r12	
    b66e:	0c df       	bis	r15,	r12	
    b670:	1c f3       	and	#1,	r12	;r3 As==01
    b672:	1b 24       	jz	$+56     	;abs 0xb6aa
    b674:	0c 4e       	mov	r14,	r12	
    b676:	0c ef       	xor	r15,	r12	
    b678:	1c f3       	and	#1,	r12	;r3 As==01
    b67a:	07 20       	jnz	$+16     	;abs 0xb68a
    b67c:	2d 93       	cmp	#2,	r13	;r3 As==10
    b67e:	07 28       	jnc	$+16     	;abs 0xb68e
    b680:	0b 4e       	mov	r14,	r11	
    b682:	1b f3       	and	#1,	r11	;r3 As==01
    b684:	2c 43       	mov	#2,	r12	;r3 As==10
    b686:	0c 8b       	sub	r11,	r12	
    b688:	03 3c       	jmp	$+8      	;abs 0xb690
    b68a:	0c 4d       	mov	r13,	r12	
    b68c:	01 3c       	jmp	$+4      	;abs 0xb690
    b68e:	1c 43       	mov	#1,	r12	;r3 As==01
    b690:	0d 8c       	sub	r12,	r13	
    b692:	0a 4c       	mov	r12,	r10	
    b694:	09 4e       	mov	r14,	r9	
    b696:	0b 4f       	mov	r15,	r11	
    b698:	fb 49 00 00 	mov.b	@r9+,	0(r11)	;0x0000(r11)
    b69c:	1b 53       	inc	r11		
    b69e:	3a 53       	add	#-1,	r10	;r3 As==11
    b6a0:	fb 23       	jnz	$-8      	;abs 0xb698
    b6a2:	0a 4f       	mov	r15,	r10	
    b6a4:	0a 5c       	add	r12,	r10	
    b6a6:	0e 5c       	add	r12,	r14	
    b6a8:	01 3c       	jmp	$+4      	;abs 0xb6ac
    b6aa:	0a 4f       	mov	r15,	r10	
    b6ac:	0b 4d       	mov	r13,	r11	
    b6ae:	12 c3       	clrc			
    b6b0:	0b 10       	rrc	r11		
    b6b2:	0b 24       	jz	$+24     	;abs 0xb6ca
    b6b4:	09 4b       	mov	r11,	r9	
    b6b6:	08 4e       	mov	r14,	r8	
    b6b8:	0c 4a       	mov	r10,	r12	
    b6ba:	bc 48 00 00 	mov	@r8+,	0(r12)	;0x0000(r12)
    b6be:	2c 53       	incd	r12		
    b6c0:	39 53       	add	#-1,	r9	;r3 As==11
    b6c2:	fb 23       	jnz	$-8      	;abs 0xb6ba
    b6c4:	0b 5b       	rla	r11		
    b6c6:	0e 5b       	add	r11,	r14	
    b6c8:	0a 5b       	add	r11,	r10	
    b6ca:	1d f3       	and	#1,	r13	;r3 As==01
    b6cc:	3c 24       	jz	$+122    	;abs 0xb746
    b6ce:	ea 4e 00 00 	mov.b	@r14,	0(r10)	;0x0000(r10)
    b6d2:	39 3c       	jmp	$+116    	;abs 0xb746
    b6d4:	0e 5d       	add	r13,	r14	
    b6d6:	0c 4f       	mov	r15,	r12	
    b6d8:	0c 5d       	add	r13,	r12	
    b6da:	0b 4c       	mov	r12,	r11	
    b6dc:	0b de       	bis	r14,	r11	
    b6de:	1b f3       	and	#1,	r11	;r3 As==01
    b6e0:	1b 24       	jz	$+56     	;abs 0xb718
    b6e2:	0b 4c       	mov	r12,	r11	
    b6e4:	0b ee       	xor	r14,	r11	
    b6e6:	1b f3       	and	#1,	r11	;r3 As==01
    b6e8:	06 20       	jnz	$+14     	;abs 0xb6f6
    b6ea:	3d 90 03 00 	cmp	#3,	r13	;#0x0003
    b6ee:	03 28       	jnc	$+8      	;abs 0xb6f6
    b6f0:	0b 4e       	mov	r14,	r11	
    b6f2:	1b f3       	and	#1,	r11	;r3 As==01
    b6f4:	01 3c       	jmp	$+4      	;abs 0xb6f8
    b6f6:	0b 4d       	mov	r13,	r11	
    b6f8:	0d 8b       	sub	r11,	r13	
    b6fa:	09 4e       	mov	r14,	r9	
    b6fc:	0a 4c       	mov	r12,	r10	
    b6fe:	08 4b       	mov	r11,	r8	
    b700:	08 8c       	sub	r12,	r8	
    b702:	3a 53       	add	#-1,	r10	;r3 As==11
    b704:	39 53       	add	#-1,	r9	;r3 As==11
    b706:	ea 49 00 00 	mov.b	@r9,	0(r10)	;0x0000(r10)
    b70a:	07 4a       	mov	r10,	r7	
    b70c:	07 58       	add	r8,	r7	
    b70e:	f9 23       	jnz	$-12     	;abs 0xb702
    b710:	3b e3       	inv	r11		
    b712:	1b 53       	inc	r11		
    b714:	0c 5b       	add	r11,	r12	
    b716:	0e 5b       	add	r11,	r14	
    b718:	0b 4d       	mov	r13,	r11	
    b71a:	12 c3       	clrc			
    b71c:	0b 10       	rrc	r11		
    b71e:	0e 24       	jz	$+30     	;abs 0xb73c
    b720:	0a 4b       	mov	r11,	r10	
    b722:	08 4e       	mov	r14,	r8	
    b724:	09 4c       	mov	r12,	r9	
    b726:	28 83       	decd	r8		
    b728:	29 83       	decd	r9		
    b72a:	a9 48 00 00 	mov	@r8,	0(r9)	;0x0000(r9)
    b72e:	3a 53       	add	#-1,	r10	;r3 As==11
    b730:	fa 23       	jnz	$-10     	;abs 0xb726
    b732:	0a 8b       	sub	r11,	r10	
    b734:	0b 4a       	mov	r10,	r11	
    b736:	0b 5b       	rla	r11		
    b738:	0e 5b       	add	r11,	r14	
    b73a:	0c 5b       	add	r11,	r12	
    b73c:	1d f3       	and	#1,	r13	;r3 As==01
    b73e:	03 24       	jz	$+8      	;abs 0xb746
    b740:	dc 4e ff ff 	mov.b	-1(r14),-1(r12)	;0xffff(r14), 0xffff(r12)
    b744:	ff ff 
    b746:	37 41       	pop	r7		
    b748:	38 41       	pop	r8		
    b74a:	39 41       	pop	r9		
    b74c:	3a 41       	pop	r10		
    b74e:	3b 41       	pop	r11		
    b750:	30 41       	ret			

0000b752 <memset>:
    b752:	0b 12       	push	r11		
    b754:	0a 12       	push	r10		
    b756:	09 12       	push	r9		
    b758:	08 12       	push	r8		
    b75a:	3d 90 06 00 	cmp	#6,	r13	;#0x0006
    b75e:	09 2c       	jc	$+20     	;abs 0xb772
    b760:	0c 4f       	mov	r15,	r12	
    b762:	04 3c       	jmp	$+10     	;abs 0xb76c
    b764:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
    b768:	1c 53       	inc	r12		
    b76a:	3d 53       	add	#-1,	r13	;r3 As==11
    b76c:	0d 93       	tst	r13		
    b76e:	fa 23       	jnz	$-10     	;abs 0xb764
    b770:	20 3c       	jmp	$+66     	;abs 0xb7b2
    b772:	4e 4e       	mov.b	r14,	r14	
    b774:	4b 4e       	mov.b	r14,	r11	
    b776:	0b 93       	tst	r11		
    b778:	03 24       	jz	$+8      	;abs 0xb780
    b77a:	0c 4b       	mov	r11,	r12	
    b77c:	8c 10       	swpb	r12		
    b77e:	0b dc       	bis	r12,	r11	
    b780:	1f b3       	bit	#1,	r15	;r3 As==01
    b782:	06 24       	jz	$+14     	;abs 0xb790
    b784:	3d 53       	add	#-1,	r13	;r3 As==11
    b786:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    b78a:	09 4f       	mov	r15,	r9	
    b78c:	19 53       	inc	r9		
    b78e:	01 3c       	jmp	$+4      	;abs 0xb792
    b790:	09 4f       	mov	r15,	r9	
    b792:	0c 4d       	mov	r13,	r12	
    b794:	12 c3       	clrc			
    b796:	0c 10       	rrc	r12		
    b798:	0a 49       	mov	r9,	r10	
    b79a:	08 4c       	mov	r12,	r8	
    b79c:	8a 4b 00 00 	mov	r11,	0(r10)	;0x0000(r10)
    b7a0:	2a 53       	incd	r10		
    b7a2:	38 53       	add	#-1,	r8	;r3 As==11
    b7a4:	fb 23       	jnz	$-8      	;abs 0xb79c
    b7a6:	0c 5c       	rla	r12		
    b7a8:	0c 59       	add	r9,	r12	
    b7aa:	1d f3       	and	#1,	r13	;r3 As==01
    b7ac:	02 24       	jz	$+6      	;abs 0xb7b2
    b7ae:	cc 4e 00 00 	mov.b	r14,	0(r12)	;0x0000(r12)
    b7b2:	38 41       	pop	r8		
    b7b4:	39 41       	pop	r9		
    b7b6:	3a 41       	pop	r10		
    b7b8:	3b 41       	pop	r11		
    b7ba:	30 41       	ret			

Disassembly of section .isr1:

0000dc00 <timer>:
                   "\n\t");
}

#pragma vector = TIMERA0_VECTOR
__interrupt __attribute__((section(".exec.init1"))) void timer(void)
{
    dc00:	0f 12       	push	r15		
    dc02:	0e 12       	push	r14		
    dc04:	0d 12       	push	r13		
    dc06:	0c 12       	push	r12		
    dc08:	0b 12       	push	r11		
    dc0a:	0a 12       	push	r10		
    dc0c:	04 12       	push	r4		
    dc0e:	04 41       	mov	r1,	r4	
    dc10:	34 50 0e 00 	add	#14,	r4	;#0x000e
    dc14:	31 50 4a ff 	add	#-182,	r1	;#0xff4a
  __asm__ volatile("mov    r1,   r6"
    dc18:	06 41       	mov	r1,	r6	
                   "\n\t");
  __asm__ volatile("mov    #0x1000,     r1"
    dc1a:	31 40 00 10 	mov	#4096,	r1	;#0x1000
                   "\n\t");
  __asm__ volatile("dint"
    dc1e:	32 c2       	dint			
                   "\n\t");
  struct auth_rep retrieved_struct;
  struct auth_rep *ptr = (struct auth_rep *)(uintptr_t)0x5800;
  retrieved_struct = *ptr;
    dc20:	3d 40 28 00 	mov	#40,	r13	;#0x0028
    dc24:	3e 40 00 58 	mov	#22528,	r14	;#0x5800
    dc28:	0f 44       	mov	r4,	r15	
    dc2a:	3f 50 3c ff 	add	#-196,	r15	;#0xff3c
    dc2e:	b0 12 58 b6 	call	#0xb658	

  uint32_t tim;
  uint32_t *timptr = (uint32_t)(uintptr_t)0x5768;
  uint32_t wait = retrieved_struct.cur_time * 6;
  tim = *timptr;
    dc32:	1a 42 68 57 	mov	&0x5768,r10	
    dc36:	1b 42 6a 57 	mov	&0x576a,r11	
  struct auth_rep *ptr = (struct auth_rep *)(uintptr_t)0x5800;
  retrieved_struct = *ptr;

  uint32_t tim;
  uint32_t *timptr = (uint32_t)(uintptr_t)0x5768;
  uint32_t wait = retrieved_struct.cur_time * 6;
    dc3a:	1c 44 40 ff 	mov	-192(r4),r12	;0xff40(r4)
    dc3e:	1d 44 42 ff 	mov	-190(r4),r13	;0xff42(r4)
    dc42:	0e 4c       	mov	r12,	r14	
    dc44:	0f 4d       	mov	r13,	r15	
    dc46:	0e 5e       	rla	r14		
    dc48:	0f 6f       	rlc	r15		
    dc4a:	0e 5c       	add	r12,	r14	
    dc4c:	0f 6d       	addc	r13,	r15	
    dc4e:	0e 5e       	rla	r14		
    dc50:	0f 6f       	rlc	r15		
  tim = *timptr;
  if (tim > wait)
    dc52:	0f 9b       	cmp	r11,	r15	
    dc54:	04 28       	jnc	$+10     	;abs 0xdc5e
    dc56:	0b 9f       	cmp	r15,	r11	
    dc58:	92 28       	jnc	$+294    	;abs 0xdd7e
    dc5a:	0e 9a       	cmp	r10,	r14	
    dc5c:	90 2c       	jc	$+290    	;abs 0xdd7e
  {
    //    send_buf(&retrieved_struct,  sizeof(retrieved_struct));
    uint8_t key[SIZE_KEY] = {0};
    dc5e:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    dc62:	0e 43       	clr	r14		
    dc64:	0f 44       	mov	r4,	r15	
    dc66:	3f 50 84 ff 	add	#-124,	r15	;#0xff84
    dc6a:	b0 12 52 b7 	call	#0xb752	
    uint8_t auth_rep[SIZE_SIGNATURE] = {0};
    dc6e:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    dc72:	0e 43       	clr	r14		
    dc74:	0f 44       	mov	r4,	r15	
    dc76:	3f 50 64 ff 	add	#-156,	r15	;#0xff64
    dc7a:	b0 12 52 b7 	call	#0xb752	
    memset(key, 0, SIZE_KEY);
    dc7e:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    dc82:	0e 43       	clr	r14		
    dc84:	0f 44       	mov	r4,	r15	
    dc86:	3f 50 84 ff 	add	#-124,	r15	;#0xff84
    dc8a:	b0 12 52 b7 	call	#0xb752	
    memcpy(key, (uint8_t *)KEY_ADDR, SIZE_KEY); // K
    dc8e:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    dc92:	3e 40 00 6a 	mov	#27136,	r14	;#0x6a00
    dc96:	0f 44       	mov	r4,	r15	
    dc98:	3f 50 84 ff 	add	#-124,	r15	;#0xff84
    dc9c:	b0 12 58 b6 	call	#0xb658	
    hmac((uint8_t *)auth_rep, (uint8_t *)key, (uint32_t)SIZE_KEY, (uint8_t *)&retrieved_struct, (uint32_t)(sizeof(retrieved_struct)));
    dca0:	03 12       	push	#0		;r3 As==00
    dca2:	30 12 28 00 	push	#40		;#0x0028
    dca6:	3e 40 3c ff 	mov	#-196,	r14	;#0xff3c
    dcaa:	0e 54       	add	r4,	r14	
    dcac:	0e 12       	push	r14		
    dcae:	3c 40 20 00 	mov	#32,	r12	;#0x0020
    dcb2:	0d 43       	clr	r13		
    dcb4:	3e 50 48 00 	add	#72,	r14	;#0x0048
    dcb8:	0f 44       	mov	r4,	r15	
    dcba:	3f 50 64 ff 	add	#-156,	r15	;#0xff64
    dcbe:	b0 12 fe b5 	call	#0xb5fe	
    dcc2:	31 50 06 00 	add	#6,	r1	;#0x0006

    // send_buf(&auth_rep, SIZE_HASH);

    struct att_rep att_rep;

    att_rep.msg_type = MSG_TYPE_REP;
    dcc6:	e4 43 a4 ff 	mov.b	#2,	-92(r4)	;r3 As==10, 0xffa4(r4)
    att_rep.dev_id = dev_id;
    dcca:	1e 42 00 02 	mov	&0x0200,r14	
    dcce:	1f 42 02 02 	mov	&0x0202,r15	
    dcd2:	c4 4e a5 ff 	mov.b	r14,	-91(r4)	;0xffa5(r4)
    dcd6:	8e 10       	swpb	r14		
    dcd8:	c4 4e a6 ff 	mov.b	r14,	-90(r4)	;0xffa6(r4)
    dcdc:	c4 4f a7 ff 	mov.b	r15,	-89(r4)	;0xffa7(r4)
    dce0:	8f 10       	swpb	r15		
    dce2:	c4 4f a8 ff 	mov.b	r15,	-88(r4)	;0xffa8(r4)
    att_rep.par = parent;
    dce6:	1e 42 2c 12 	mov	&0x122c,r14	
    dcea:	1f 42 2e 12 	mov	&0x122e,r15	
    dcee:	c4 4e a9 ff 	mov.b	r14,	-87(r4)	;0xffa9(r4)
    dcf2:	8e 10       	swpb	r14		
    dcf4:	c4 4e aa ff 	mov.b	r14,	-86(r4)	;0xffaa(r4)
    dcf8:	c4 4f ab ff 	mov.b	r15,	-85(r4)	;0xffab(r4)
    dcfc:	8f 10       	swpb	r15		
    dcfe:	c4 4f ac ff 	mov.b	r15,	-84(r4)	;0xffac(r4)
    att_rep.attesttime = retrieved_struct.cur_time;               
    dd02:	1e 44 40 ff 	mov	-192(r4),r14	;0xff40(r4)
    dd06:	1f 44 42 ff 	mov	-190(r4),r15	;0xff42(r4)
    dd0a:	c4 4e ad ff 	mov.b	r14,	-83(r4)	;0xffad(r4)
    dd0e:	8e 10       	swpb	r14		
    dd10:	c4 4e ae ff 	mov.b	r14,	-82(r4)	;0xffae(r4)
    dd14:	c4 4f af ff 	mov.b	r15,	-81(r4)	;0xffaf(r4)
    dd18:	8f 10       	swpb	r15		
    dd1a:	c4 4f b0 ff 	mov.b	r15,	-80(r4)	;0xffb0(r4)
    memcpy(att_rep.new_hash, retrieved_struct.new_hash, SIZE_HASH); 
    dd1e:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    dd22:	0e 44       	mov	r4,	r14	
    dd24:	3e 50 44 ff 	add	#-188,	r14	;#0xff44
    dd28:	0f 44       	mov	r4,	r15	
    dd2a:	3f 50 b1 ff 	add	#-79,	r15	;#0xffb1
    dd2e:	b0 12 58 b6 	call	#0xb658	
    memcpy(att_rep.auth_rep, auth_rep, SIZE_HASH);                 
    dd32:	3d 40 20 00 	mov	#32,	r13	;#0x0020
    dd36:	0e 44       	mov	r4,	r14	
    dd38:	3e 50 64 ff 	add	#-156,	r14	;#0xff64
    dd3c:	0f 44       	mov	r4,	r15	
    dd3e:	3f 50 d1 ff 	add	#-47,	r15	;#0xffd1
    dd42:	b0 12 58 b6 	call	#0xb658	

    send_buf(&att_rep, sizeof(att_rep));
    dd46:	3e 40 4d 00 	mov	#77,	r14	;#0x004d
    dd4a:	0f 44       	mov	r4,	r15	
    dd4c:	3f 50 a4 ff 	add	#-92,	r15	;#0xffa4
    dd50:	b0 12 92 a2 	call	#0xa292	

    CCTL0 &= ~CCIE;
    dd54:	3f 40 62 01 	mov	#354,	r15	;#0x0162
    dd58:	2e 4f       	mov	@r15,	r14	
    dd5a:	3e f0 ef ff 	and	#-17,	r14	;#0xffef
    dd5e:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    UART_CTL = UART_EN | UART_IEN_RX;
    dd62:	f2 40 11 00 	mov.b	#17,	&0x0080	;#0x0011
    dd66:	80 00 
    epoch_time++;
    dd68:	1e 42 3c 13 	mov	&0x133c,r14	
    dd6c:	1f 42 3e 13 	mov	&0x133e,r15	
    dd70:	1e 53       	inc	r14		
    dd72:	0f 63       	adc	r15		
    dd74:	82 4e 3c 13 	mov	r14,	&0x133c	
    dd78:	82 4f 3e 13 	mov	r15,	&0x133e	
    dd7c:	08 3c       	jmp	$+18     	;abs 0xdd8e
    tim = 0;
  }
  else
  {
    tim++;
    dd7e:	0e 4a       	mov	r10,	r14	
    dd80:	0f 4b       	mov	r11,	r15	
    dd82:	1e 53       	inc	r14		
    dd84:	0f 63       	adc	r15		
    dd86:	82 4e 68 57 	mov	r14,	&0x5768	
    dd8a:	82 4f 6a 57 	mov	r15,	&0x576a	
    uintptr_t timer_address = (uintptr_t)0x5768;
    uint32_t *timerptr = (uint32_t *)timer_address;
    *timerptr = tim;
  }
  __asm__ volatile("eint"
    dd8e:	32 d2       	eint			
                   "\n\t");
  __asm__ volatile("mov    r6,   r1"
    dd90:	01 46       	mov	r6,	r1	
                   "\n\t");
  __asm__ volatile("add	#182,	r1"
    dd92:	31 50 b6 00 	add	#182,	r1	;#0x00b6
                   "\n\t");
  __asm__ volatile("pop r4"
    dd96:	34 41       	pop	r4		
                   "\n\t");
  __asm__ volatile("pop r10"
    dd98:	3a 41       	pop	r10		
                   "\n\t");
  __asm__ volatile("pop r11"
    dd9a:	3b 41       	pop	r11		
                   "\n\t");
  __asm__ volatile("pop r12"
    dd9c:	3c 41       	pop	r12		
                   "\n\t");
  __asm__ volatile("pop r13"
    dd9e:	3d 41       	pop	r13		
                   "\n\t");
  __asm__ volatile("pop r14"
    dda0:	3e 41       	pop	r14		
                   "\n\t");
  __asm__ volatile("pop r15"
    dda2:	3f 41       	pop	r15		
                   "\n\t");
  __asm__ volatile("pop r2"
    dda4:	32 41       	pop	r2		
                   "\n\t");
  __asm__ volatile("pop r5"
    dda6:	35 41       	pop	r5		
                   "\n\t");
  __asm__ volatile("br #__mac_leave"
    dda8:	30 40 fe df 	br	#0xdffe	
                   "\n\t");
}
    ddac:	31 50 b6 00 	add	#182,	r1	;#0x00b6
    ddb0:	34 41       	pop	r4		
    ddb2:	3a 41       	pop	r10		
    ddb4:	3b 41       	pop	r11		
    ddb6:	3c 41       	pop	r12		
    ddb8:	3d 41       	pop	r13		
    ddba:	3e 41       	pop	r14		
    ddbc:	3f 41       	pop	r15		
    ddbe:	00 13       	reti			

Disassembly of section .isr2:

0000de00 <uart>:

#pragma vector = UART_RX_VECTOR
__interrupt __attribute__((section(".exec.init2"))) void uart(void)
{
    de00:	0f 12       	push	r15		
    de02:	0e 12       	push	r14		
    de04:	0d 12       	push	r13		
    de06:	0c 12       	push	r12		
    de08:	21 83       	decd	r1		
  __asm__ volatile("mov    r1,   r6"
    de0a:	06 41       	mov	r1,	r6	
                   "\n\t");
  __asm__ volatile("mov    #0x1000,     r1"
    de0c:	31 40 00 10 	mov	#4096,	r1	;#0x1000
                   "\n\t");
  __asm__ volatile("dint"
    de10:	32 c2       	dint			
                   "\n\t");
  uint8_t sendByte = ACK;
    de12:	f1 40 61 00 	mov.b	#97,	0(r1)	;#0x0061, 0x0000(r1)
    de16:	00 00 
  send_buf(&sendByte, sizeof(sendByte));
    de18:	1e 43       	mov	#1,	r14	;r3 As==01
    de1a:	0f 41       	mov	r1,	r15	
    de1c:	b0 12 92 a2 	call	#0xa292	

  read_byte();
    de20:	b0 12 ba a2 	call	#0xa2ba	
  // P3OUT = ~P3OUT;
  TACCTL0 &= ~CCIFG;
    de24:	3f 40 62 01 	mov	#354,	r15	;#0x0162
    de28:	2e 4f       	mov	@r15,	r14	
    de2a:	3e f0 fe ff 	and	#-2,	r14	;#0xfffe
    de2e:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
  __asm__ volatile("eint"
    de32:	32 d2       	eint			
                   "\n\t");
  //reenable interrupts
  // clear any pending timer interrupts
  __asm__ volatile("mov    r6,   r1"
    de34:	01 46       	mov	r6,	r1	
                   "\n\t");
  __asm__ volatile("incd	r1"
    de36:	21 53       	incd	r1		
                   "\n\t");
  __asm__ volatile("pop r12"
    de38:	3c 41       	pop	r12		
                   "\n\t");
  __asm__ volatile("pop r13"
    de3a:	3d 41       	pop	r13		
                   "\n\t");
  __asm__ volatile("pop r14"
    de3c:	3e 41       	pop	r14		
                   "\n\t");
  __asm__ volatile("pop r15"
    de3e:	3f 41       	pop	r15		
                   "\n\t");
  __asm__ volatile("pop r2"
    de40:	32 41       	pop	r2		
                   "\n\t");
  __asm__ volatile("pop r5"
    de42:	35 41       	pop	r5		
                   "\n\t");
  __asm__ volatile("br      #__mac_leave"
    de44:	30 40 fe df 	br	#0xdffe	
                   "\n\t");
}
    de48:	21 53       	incd	r1		
    de4a:	3c 41       	pop	r12		
    de4c:	3d 41       	pop	r13		
    de4e:	3e 41       	pop	r14		
    de50:	3f 41       	pop	r15		
    de52:	00 13       	reti			

Disassembly of section .srom2:

0000dffe <CASU_exit>:
}

/* [CASU-SW] Exit function */
__attribute__((section(".do_mac.leave"))) __attribute__((naked)) void CASU_exit()
{
  __asm__ volatile("br   r5"
    dffe:	00 45       	br	r5		

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	92 e0 92 e0 92 e0 92 e0 92 e0 92 e0 92 e0 92 e0     ................
    fff0:	92 e0 00 dc 92 e0 00 de 92 e0 92 e0 92 e0 00 a0     ................
